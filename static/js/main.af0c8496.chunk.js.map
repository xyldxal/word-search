{"version":3,"sources":["utils/gridHelper.js","components/Grid.js","components/Word.js","utils/gameLogic.js","components/Timer.js","components/Score.js","utils/wordGenerator.js","utils/storage.js","components/Level.js","data/levels.js","App.js","index.js"],"names":["coordsToIndex","x","y","size","indexToCoords","index","Math","floor","getWordFromSelection","selectedIndices","letters","map","join","isValidSelection","length","coords","dx","dy","max","abs","dirX","dirY","i","newDx","newDy","newLength","GridContainer","styled","div","_templateObject","_taggedTemplateLiteral","props","SelectionLine","_templateObject2","Cell","_templateObject3","Grid","_ref","onWordFound","foundWords","selectedCells","setSelectedCells","useState","isDragging","setIsDragging","foundCells","setFoundCells","Set","gridRef","useRef","colors","calculateSelectionStyle","current","gridRect","getBoundingClientRect","totalGaps","cellSize","width","fullCellSize","startCell","endCell","start","end","x1","y1","x2","y2","colorIndex","random","concat","stroke","strokeWidth","useEffect","newFoundCells","startIndex","word","directions","indices","currentWord","currentIndex","newX","newY","push","split","reverse","forEach","add","handleCellMouseUp","React","createElement","ref","onMouseLeave","onTouchStart","e","preventDefault","onTouchMove","touch","touches","cellWidth","cellHeight","height","clientX","left","clientY","top","col","row","newSelection","onTouchEnd","handleTouchEnd","renderHighlights","styles","selectionStyle","_objectSpread","opacity","key","wordIndex","startX","startY","gap","padding","style","position","pointerEvents","strokeLinecap","letter","onMouseDown","handleCellMouseDown","onMouseEnter","handleCellMouseEnter","onMouseUp","handleTouchStart","WordItem","found","Word","formatTime","seconds","minutes","remainingSeconds","toString","padStart","TimerContainer","time","Timer","initialTime","onTimeUp","setTime","timer","setInterval","prev","clearInterval","ScoreContainer","Score","score","DIRECTIONS","canPlaceWord","grid","pos","dir","wordLength","currentCell","placeWord","saveGameProgress","data","localStorage","setItem","JSON","stringify","error","console","loadGameProgress","getItem","parse","clearGameProgress","removeItem","LevelContainer","LevelHeader","WordList","Level","levelData","onLevelComplete","setFoundWords","setScore","timeRemaining","setTimeRemaining","timeLimit","setGrid","newGrid","generateWordSearchGrid","words","Array","fill","placedWords","sort","a","b","placed","attempts","maxAttempts","gridSize","isArray","flat","id","includes","reversedWord","foundWord","find","w","toUpperCase","newFoundWords","wordScore","calculateScore","newScore","level","isLevelComplete","levelWords","every","saveHighScore","highScores","levels","difficulty","AppContainer","GameHeader","Title","h1","MenuContainer","_templateObject4","Button","button","_templateObject5","ModalOverlay","_templateObject6","Modal","_templateObject7","App","currentLevel","setCurrentLevel","totalScore","setTotalScore","highestLevel","setHighestLevel","showModal","setShowModal","modalMessage","setModalMessage","savedProgress","handleLevelComplete","levelScore","newTotalScore","newLevel","startLevel","levelNumber","resetGame","onClick","disabled","renderLevel","Fragment","whiteSpace","GlobalStyle","createGlobalStyle","root","document","getElementById","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.af0c8496.chunk.js","sourcesContent":["export const coordsToIndex = (x, y, size) => {\n    return y * size + x;\n  };\n  \n  // Convert index to grid coordinates\n  export const indexToCoords = (index, size) => ({\n    x: index % size,\n    y: Math.floor(index / size)\n  });\n  \n  // Get word from selected cells\n  export const getWordFromSelection = (selectedIndices, letters, size) => {\n    return selectedIndices\n      .map(index => letters[index])\n      .join('');\n  };\n  \n  // Check if selection is valid (continuous and in a straight line)\n  export const isValidSelection = (selectedIndices, size) => {\n    if (selectedIndices.length < 2) return false;\n  \n    const coords = selectedIndices.map(index => indexToCoords(index, size));\n    \n    // Check if points are in line (same row, column, or diagonal)\n    const dx = coords[1].x - coords[0].x;\n    const dy = coords[1].y - coords[0].y;\n    \n    // Normalize direction\n    const length = Math.max(Math.abs(dx), Math.abs(dy));\n    const dirX = dx / length;\n    const dirY = dy / length;\n  \n    // Check if all points follow the same direction\n    for (let i = 2; i < coords.length; i++) {\n      const newDx = coords[i].x - coords[i-1].x;\n      const newDy = coords[i].y - coords[i-1].y;\n      const newLength = Math.max(Math.abs(newDx), Math.abs(newDy));\n      \n      if (newDx/newLength !== dirX || newDy/newLength !== dirY) {\n        return false;\n      }\n    }\n  \n    return true;\n  };","import React, { useState, useRef, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { isValidSelection, getWordFromSelection, indexToCoords, coordsToIndex } from '../utils/gridHelper';\n\nconst GridContainer = styled.div`\n  position: relative;\n  display: grid;\n  grid-template-columns: repeat(${props => props.size}, 1fr);\n  gap: 2px;\n  padding: 10px;\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 100%;\n  max-width: 700px;\n  margin: 0 auto;\n  touch-action: none; /* Only prevent default touch actions on the grid */\n\n  @media (max-width: 768px) {\n    padding: 5px;\n    gap: 1px;\n    max-width: 95vw;\n  }\n`;\n\nconst SelectionLine = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 1;\n`;\n\nconst Cell = styled.div`\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  aspect-ratio: 1;\n  font-size: 1.2em;\n  font-weight: bold;\n  cursor: pointer;\n  user-select: none;\n  color: #333;\n\n  @media (max-width: 768px) {\n    font-size: 0.9em;\n  }\n`;\n\nconst Grid = ({ size, letters, onWordFound, foundWords = [] }) => {\n  const [selectedCells, setSelectedCells] = useState([]);\n  const [isDragging, setIsDragging] = useState(false);\n  const [foundCells, setFoundCells] = useState(new Set());\n  const gridRef = useRef(null);\n\n  const colors = [\n    '#FF9AA2', // pink\n    '#FFB7B2', // salmon\n    '#FFDAC1', // peach\n    '#E2F0CB', // light green\n    '#B5EAD7', // mint\n    '#C7CEEA', // periwinkle\n    '#9DD6FF', // light blue\n  ];\n\n  const calculateSelectionStyle = () => {\n    if (selectedCells.length < 2 || !gridRef.current) return null;\n\n    const gridRect = gridRef.current.getBoundingClientRect();\n    const gap = 2;\n    const padding = 10;\n    const totalGaps = size - 1;\n    const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n    const cellSize = availableSpace / size;\n    const fullCellSize = cellSize + gap;\n    \n    const startCell = selectedCells[0];\n    const endCell = selectedCells[selectedCells.length - 1];\n    const start = indexToCoords(startCell, size);\n    const end = indexToCoords(endCell, size);\n\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    \n    // Calculate center points for all cases\n    const x1 = padding + (start.x * fullCellSize) + cellSize/2;\n    const y1 = padding + (start.y * fullCellSize) + cellSize/2;\n    const x2 = padding + (end.x * fullCellSize) + cellSize/2;\n    const y2 = padding + (end.y * fullCellSize) + cellSize/2;\n    \n    const colorIndex = Math.floor(Math.random() * colors.length);\n    \n    return {\n      x1: `${x1}px`,\n      y1: `${y1}px`,\n      x2: `${x2}px`,\n      y2: `${y2}px`,\n      stroke: colors[colorIndex],\n      strokeWidth: cellSize,\n    };\n  };\n\n  const renderHighlights = () => {\n    const styles = [];\n    \n    // Add current selection highlight\n    const selectionStyle = calculateSelectionStyle();\n    if (selectionStyle) {\n      styles.push({\n        ...selectionStyle,\n        opacity: 0.3,\n        key: 'selection'\n      });\n    }\n    \n    // Add permanent highlights for found words\n    foundWords.forEach((word, wordIndex) => {\n      for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let currentWord = '';\n          let x1, y1, x2, y2;\n          \n          const { x: startX, y: startY } = indexToCoords(startIndex, size);\n          const gridRect = gridRef.current.getBoundingClientRect();\n          const gap = 2;\n          const padding = 10;\n          const totalGaps = size - 1;\n          const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n          const cellSize = availableSpace / size;\n          const fullCellSize = cellSize + gap;\n          \n          for (let i = 0; i < word.length; i++) {\n            const newX = startX + (dx * i);\n            const newY = startY + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            \n            if (i === 0) {\n              x1 = padding + (newX * fullCellSize) + cellSize/2;\n              y1 = padding + (newY * fullCellSize) + cellSize/2;\n            } else if (i === word.length - 1) {\n              x2 = padding + (newX * fullCellSize) + cellSize/2;\n              y2 = padding + (newY * fullCellSize) + cellSize/2;\n            }\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            styles.push({\n              x1: `${x1}px`,\n              y1: `${y1}px`,\n              x2: `${x2}px`,\n              y2: `${y2}px`,\n              stroke: colors[wordIndex % colors.length],\n              strokeWidth: cellSize,\n              opacity: 0.3,\n              key: `found-${wordIndex}-${startIndex}-${dx}-${dy}`\n            });\n            break; // Found the word, no need to check other directions from this start point\n          }\n        }\n      }\n    });\n\n    return (\n      <svg\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n        }}\n      >\n        {styles.map(style => (\n          <line\n            key={style.key}\n            x1={style.x1}\n            y1={style.y1}\n            x2={style.x2}\n            y2={style.y2}\n            stroke={style.stroke}\n            strokeWidth={style.strokeWidth}\n            strokeLinecap=\"round\"\n            opacity={style.opacity}\n          />\n        ))}\n      </svg>\n    );\n  };\n\n  useEffect(() => {\n    const style = calculateSelectionStyle();\n    if (!style) return;\n  }, [selectedCells]);\n\n  useEffect(() => {\n    const newFoundCells = new Set();\n    \n    for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n      for (const word of foundWords) {\n        // Check all 8 directions from this starting point\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let indices = [];\n          let currentWord = '';\n          let currentIndex = startIndex;\n          \n          for (let i = 0; i < word.length; i++) {\n            const { x, y } = indexToCoords(currentIndex, size);\n            const newX = x + (dx * i);\n            const newY = y + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            indices.push(index);\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            indices.forEach(index => newFoundCells.add(index));\n          }\n        }\n      }\n    }\n    \n    setFoundCells(newFoundCells);\n  }, [foundWords, letters, size]);\n\n  const handleCellMouseDown = (index) => {\n    setIsDragging(true);\n    setSelectedCells([index]);\n  };\n\n  const handleCellMouseEnter = (index) => {\n    if (isDragging) {\n      const newSelection = [...selectedCells, index];\n      if (isValidSelection(newSelection, size)) {\n        setSelectedCells(newSelection);\n      }\n    }\n  };\n\n  const handleCellMouseUp = () => {\n    setIsDragging(false);\n    if (selectedCells.length >= 2) {\n      const word = getWordFromSelection(selectedCells, letters, size);\n      onWordFound(word);\n    }\n    setSelectedCells([]);\n  };\n\n  const handleTouchStart = (index, e) => {\n    e.preventDefault();\n    setIsDragging(true);\n    setSelectedCells([index]);\n  };\n\n  const handleTouchMove = (e) => {\n    e.preventDefault();\n    if (!isDragging || !gridRef.current) return;\n\n    const touch = e.touches[0];\n    const grid = gridRef.current;\n    const gridRect = grid.getBoundingClientRect();\n    const cellWidth = gridRect.width / size;\n    const cellHeight = gridRect.height / size;\n\n    // Get touch position relative to grid\n    const x = touch.clientX - gridRect.left;\n    const y = touch.clientY - gridRect.top;\n\n    // Convert to grid coordinates\n    const col = Math.floor(x / cellWidth);\n    const row = Math.floor(y / cellHeight);\n\n    if (col >= 0 && col < size && row >= 0 && row < size) {\n      const index = row * size + col;\n      const newSelection = [...selectedCells];\n      \n      // Only add if it's not the last cell selected\n      if (index !== newSelection[newSelection.length - 1]) {\n        newSelection.push(index);\n        if (isValidSelection(newSelection, size)) {\n          setSelectedCells(newSelection);\n        }\n      }\n    }\n  };\n\n  const handleTouchEnd = () => {\n    if (selectedCells.length >= 2) {\n      const word = getWordFromSelection(selectedCells, letters, size);\n      onWordFound(word);\n    }\n    setIsDragging(false);\n    setSelectedCells([]);\n  };\n\n  return (\n    <GridContainer \n      ref={gridRef}\n      size={size}\n      onMouseLeave={() => {\n        setIsDragging(false);\n        setSelectedCells([]);\n      }}\n      onTouchStart={(e) => e.preventDefault()}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n    >\n      <SelectionLine>\n        {renderHighlights()}\n      </SelectionLine>\n      {letters.map((letter, index) => (\n        <Cell\n          key={index}\n          onMouseDown={() => handleCellMouseDown(index)}\n          onMouseEnter={() => handleCellMouseEnter(index)}\n          onMouseUp={handleCellMouseUp}\n          onTouchStart={(e) => handleTouchStart(index, e)}\n        >\n          {letter}\n        </Cell>\n      ))}\n    </GridContainer>\n  );\n};\n\nexport default Grid;","// src/components/Word.js\nimport React from 'react';\nimport styled from 'styled-components';\n\nconst WordItem = styled.div`\n  padding: 8px 15px;\n  background-color: ${props => props.found ? '#4CAF50' : 'white'};\n  color: ${props => props.found ? 'white' : 'black'};\n  border-radius: 20px;\n  font-weight: bold;\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  transition: all 0.3s ease;\n  \n  @media (max-width: 768px) {\n    padding: 6px 12px;\n    font-size: 0.9em;\n  }\n`;\n\nconst Word = ({ word, found }) => {\n  return (\n    <WordItem found={found}>\n      {word}\n    </WordItem>\n  );\n};\n\nexport default Word;","export const calculateScore = (wordLength, timeRemaining) => {\r\n    const baseScore = wordLength * 10;\r\n    const timeBonus = Math.floor(timeRemaining / 10);\r\n    return baseScore + timeBonus;\r\n  };\r\n  \r\n  // Check if level is complete\r\n  export const isLevelComplete = (foundWords, levelWords) => {\r\n    return foundWords.length === levelWords.length &&\r\n      levelWords.every(word => foundWords.includes(word));\r\n  };\r\n  \r\n  // Get difficulty multiplier\r\n  export const getDifficultyMultiplier = (difficulty) => {\r\n    switch (difficulty.toLowerCase()) {\r\n      case 'easy':\r\n        return 1;\r\n      case 'medium':\r\n        return 1.5;\r\n      case 'hard':\r\n        return 2;\r\n      default:\r\n        return 1;\r\n    }\r\n  };\r\n  \r\n  // Format time for display\r\n  export const formatTime = (seconds) => {\r\n    const minutes = Math.floor(seconds / 60);\r\n    const remainingSeconds = seconds % 60;\r\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\r\n  };\r\n  \r\n  // Generate level summary\r\n  export const generateLevelSummary = (score, foundWords, totalTime, difficulty) => {\r\n    const difficultyMultiplier = getDifficultyMultiplier(difficulty);\r\n    const finalScore = Math.floor(score * difficultyMultiplier);\r\n    \r\n    return {\r\n      score: finalScore,\r\n      wordsFound: foundWords.length,\r\n      timeSpent: formatTime(totalTime),\r\n      difficulty,\r\n      perfectScore: foundWords.length === totalTime\r\n    };\r\n  };","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\nimport { formatTime } from '../utils/gameLogic';\r\n\r\nconst TimerContainer = styled.div`\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: ${props => props.time < 10 ? 'red' : 'black'};\r\n`;\r\n\r\nconst Timer = ({ initialTime, onTimeUp }) => {\r\n  const [time, setTime] = useState(initialTime);\r\n\r\n  useEffect(() => {\r\n    if (time === 0) {\r\n      onTimeUp();\r\n      return;\r\n    }\r\n\r\n    const timer = setInterval(() => {\r\n      setTime(prev => prev - 1);\r\n    }, 1000);\r\n\r\n    return () => clearInterval(timer);\r\n  }, [time, onTimeUp]);\r\n\r\n  return (\r\n    <TimerContainer time={time}>\r\n      {formatTime(time)}\r\n    </TimerContainer>\r\n  );\r\n};\r\n\r\nexport default Timer;\r\n","// src/components/Score.js\r\nimport React from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst ScoreContainer = styled.div`\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: #4CAF50;\r\n  padding: 10px 20px;\r\n  background-color: #f5f5f5;\r\n  border-radius: 10px;\r\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n`;\r\n\r\nconst Score = ({ score }) => {\r\n  return (\r\n    <ScoreContainer>\r\n      Score: {score}\r\n    </ScoreContainer>\r\n  );\r\n};\r\n\r\nexport default Score;","const DIRECTIONS = [\r\n    { x: 1, y: 0 },   // right\r\n    { x: 0, y: 1 },   // down\r\n    { x: 1, y: 1 },   // diagonal right-down\r\n    { x: -1, y: 0 },  // left\r\n    { x: 0, y: -1 },  // up\r\n    { x: -1, y: -1 }, // diagonal left-up\r\n    { x: 1, y: -1 },  // diagonal right-up\r\n    { x: -1, y: 1 },  // diagonal left-down\r\n  ];\r\n  \r\n  // Check if a word can be placed at a specific position and direction\r\n  const canPlaceWord = (grid, word, pos, dir, size) => {\r\n    const { x: dx, y: dy } = dir;\r\n    const wordLength = word.length;\r\n  \r\n    for (let i = 0; i < wordLength; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n  \r\n      // Check boundaries\r\n      if (newX < 0 || newX >= size || newY < 0 || newY >= size) {\r\n        return false;\r\n      }\r\n  \r\n      // Check if cell is empty or has the same letter\r\n      const currentCell = grid[newY][newX];\r\n      if (currentCell !== '' && currentCell !== word[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n  \r\n  // Place a word in the grid\r\n  const placeWord = (grid, word, pos, dir) => {\r\n    const { x: dx, y: dy } = dir;\r\n    \r\n    for (let i = 0; i < word.length; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n      grid[newY][newX] = word[i];\r\n    }\r\n  };\r\n  \r\n  // Generate the complete grid with words\r\n  export const generateWordSearchGrid = (size, words) => {\r\n    // Initialize empty grid\r\n    const grid = Array(size).fill().map(() => Array(size).fill(''));\r\n    const placedWords = [];\r\n  \r\n    // Sort words by length (longest first)\r\n    const sortedWords = [...words].sort((a, b) => b.length - a.length);\r\n  \r\n    // Try to place each word\r\n    sortedWords.forEach(word => {\r\n      let placed = false;\r\n      let attempts = 0;\r\n      const maxAttempts = size * size;\r\n  \r\n      while (!placed && attempts < maxAttempts) {\r\n        const pos = {\r\n          x: Math.floor(Math.random() * size),\r\n          y: Math.floor(Math.random() * size)\r\n        };\r\n        const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];\r\n  \r\n        if (canPlaceWord(grid, word, pos, dir, size)) {\r\n          placeWord(grid, word, pos, dir);\r\n          placedWords.push(word);\r\n          placed = true;\r\n        }\r\n        attempts++;\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty cells with random letters\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    for (let y = 0; y < size; y++) {\r\n      for (let x = 0; x < size; x++) {\r\n        if (grid[y][x] === '') {\r\n          grid[y][x] = letters[Math.floor(Math.random() * letters.length)];\r\n        }\r\n      }\r\n    }\r\n  \r\n    return { grid, placedWords };\r\n  };","// src/utils/storage.js\r\n\r\nconst STORAGE_KEY = 'wordSearchGame';\r\n\r\nexport const saveGameProgress = (data) => {\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error saving game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const loadGameProgress = () => {\r\n  try {\r\n    const data = localStorage.getItem(STORAGE_KEY);\r\n    return data ? JSON.parse(data) : null;\r\n  } catch (error) {\r\n    console.error('Error loading game progress:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const clearGameProgress = () => {\r\n  try {\r\n    localStorage.removeItem(STORAGE_KEY);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error clearing game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const saveHighScore = (level, score) => {\r\n  try {\r\n    const highScores = JSON.parse(localStorage.getItem('wordSearchHighScores') || '{}');\r\n    if (!highScores[level] || score > highScores[level]) {\r\n      highScores[level] = score;\r\n      localStorage.setItem('wordSearchHighScores', JSON.stringify(highScores));\r\n      return true;\r\n    }\r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error saving high score:', error);\r\n    return false;\r\n  }\r\n};","// src/components/Level.js\nimport React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Grid from './Grid';\nimport Word from './Word';\nimport Timer from './Timer';\nimport Score from './Score';\nimport { generateWordSearchGrid } from '../utils/wordGenerator';\nimport { calculateScore, isLevelComplete } from '../utils/gameLogic';\nimport { saveGameProgress, saveHighScore } from '../utils/storage';\n\nconst LevelContainer = styled.div`\n  padding: 20px;\n  max-width: 800px;\n  margin: 0 auto;\n\n  @media (max-width: 768px) {\n    padding: 10px;\n  }\n`;\n\nconst LevelHeader = styled.div`\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n\n  @media (max-width: 768px) {\n    margin-bottom: 10px;\n    gap: 5px;\n\n    h2 {\n      font-size: 1.5rem;\n    }\n  }\n`;\n\nconst WordList = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  gap: 10px;\n  margin-bottom: 20px;\n  justify-content: center;\n\n  @media (max-width: 768px) {\n    gap: 5px;\n    margin-bottom: 10px;\n  }\n`;\n\nconst Level = ({ levelData, onLevelComplete }) => {\n  const [foundWords, setFoundWords] = useState([]);\n  const [score, setScore] = useState(0);\n  const [timeRemaining, setTimeRemaining] = useState(levelData.timeLimit);\n  const [grid, setGrid] = useState([]);\n\n  useEffect(() => {\n    // Reset state when level changes\n    setFoundWords([]);\n    setScore(0);\n    setTimeRemaining(levelData.timeLimit);\n    \n    // Generate new grid\n    const { grid: newGrid } = generateWordSearchGrid(\n      levelData.gridSize, \n      levelData.words\n    );\n    setGrid(Array.isArray(newGrid) ? newGrid.flat() : []);\n  }, [levelData]);\n\n  const handleWordFound = (word) => {\n    if (!word) return;\n    \n    // Check both forward and reverse directions\n    const reversedWord = word.split('').reverse().join('');\n    const foundWord = levelData.words.find(w => \n      w.toUpperCase() === word.toUpperCase() || \n      w.toUpperCase() === reversedWord.toUpperCase()\n    );\n    \n    if (foundWord && !foundWords.includes(foundWord)) {\n      const newFoundWords = [...foundWords, foundWord];\n      const wordScore = calculateScore(foundWord.length, timeRemaining);\n      const newScore = score + wordScore;\n      \n      setFoundWords(newFoundWords);\n      setScore(newScore);\n\n      // Save progress\n      saveGameProgress({\n        level: levelData.id,\n        score: newScore,\n        foundWords: newFoundWords\n      });\n\n      if (isLevelComplete(newFoundWords, levelData.words)) {\n        saveHighScore(levelData.id, newScore);\n        onLevelComplete(newScore);\n      }\n    }\n  };\n\n  if (!grid.length) return null;\n\n  return (\n    <LevelContainer>\n      <LevelHeader>\n        <h2>Level {levelData.id}</h2>\n        <Score score={score} />\n        <Timer \n          initialTime={levelData.timeLimit}\n          onTimeUp={() => onLevelComplete(score)}\n        />\n      </LevelHeader>\n\n      <WordList>\n        {levelData.words.map((word, index) => (\n          <Word\n            key={index}\n            word={word}\n            found={foundWords.includes(word)}\n          />\n        ))}\n      </WordList>\n\n      <Grid\n        size={levelData.gridSize}\n        letters={grid}\n        onWordFound={handleWordFound}\n        foundWords={foundWords}\n      />\n    </LevelContainer>\n  );\n};\n\nexport default Level;","// src/data/levels.js\r\nexport const levels = [\r\n    {\r\n      id: 1,\r\n      gridSize: 15,\r\n      words: ['SHABU', 'PEKPEK', 'BURAT', 'KIFFY', 'VLAT', 'POKPOK', 'BETLOG'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    {\r\n      id: 2,\r\n      gridSize: 15,\r\n      words: ['TONI', 'FOWLER', 'JIAFEI'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    // Add more levels following the same pattern\r\n  ];\r\n  \r\n  // Helper function to generate the grid for each level\r\n  export const generateGrid = (size, words) => {\r\n    // Create empty grid\r\n    const grid = Array(size * size).fill('');\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    \r\n    // Place words in grid (simplified version)\r\n    words.forEach(word => {\r\n      const position = Math.floor(Math.random() * (size * size - word.length));\r\n      for (let i = 0; i < word.length; i++) {\r\n        grid[position + i] = word[i];\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty spaces with random letters\r\n    return grid.map(cell => cell === '' ? \r\n      letters.charAt(Math.floor(Math.random() * letters.length)) : cell\r\n    );\r\n  };","import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Level from './components/Level';\nimport { levels } from './data/levels';\nimport { loadGameProgress, saveGameProgress, clearGameProgress } from './utils/storage';\n\nconst AppContainer = styled.div`\n  min-height: 100vh;\n  background-color: #f0f2f5;\n  padding: 20px;\n  \n  @media (max-width: 768px) {\n    padding: 10px;\n  }\n`;\n\nconst GameHeader = styled.div`\n  text-align: center;\n  margin-bottom: 30px;\n  \n  @media (max-width: 768px) {\n    margin-bottom: 15px;\n  }\n`;\n\nconst Title = styled.h1`\n  color: #2c3e50;\n  font-size: 2.5rem;\n  margin-bottom: 10px;\n  \n  @media (max-width: 768px) {\n    font-size: 2rem;\n    margin-bottom: 5px;\n  }\n`;\n\nconst MenuContainer = styled.div`\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 20px;\n  background-color: white;\n  border-radius: 10px;\n  box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n  \n  @media (max-width: 768px) {\n    max-width: 95%;\n    padding: 15px;\n  }\n`;\n\nconst Button = styled.button`\n  padding: 10px 20px;\n  margin: 10px;\n  font-size: 1.1rem;\n  border: none;\n  border-radius: 5px;\n  background-color: #4CAF50;\n  color: white;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  touch-action: manipulation;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none; // Add this\n\n  &:hover {\n    background-color: #45a049;\n  }\n\n  &:active {\n    background-color: #3d8b40;\n    transform: scale(0.98);\n  }\n\n  &:disabled {\n    background-color: #cccccc;\n    cursor: not-allowed;\n  }\n  \n  @media (max-width: 768px) {\n    padding: 15px 30px; // Increased padding for better touch target\n    margin: 8px;\n    font-size: 1.2rem; // Slightly larger font for mobile\n  }\n`;\n\nconst ModalOverlay = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n`;\n\nconst Modal = styled.div`\n  position: relative;\n  background-color: white;\n  padding: 30px;\n  border-radius: 10px;\n  box-shadow: 0 0 20px rgba(0,0,0,0.2);\n  text-align: center;\n  z-index: 1001;\n`;\n\nfunction App() {\n  const [currentLevel, setCurrentLevel] = useState(0);\n  const [totalScore, setTotalScore] = useState(0);\n  const [highestLevel, setHighestLevel] = useState(1);\n  const [showModal, setShowModal] = useState(false);\n  const [modalMessage, setModalMessage] = useState('');\n\n  useEffect(() => {\n    // Load saved progress when app starts\n    const savedProgress = loadGameProgress();\n    if (savedProgress) {\n      setHighestLevel(savedProgress.level);\n      setTotalScore(savedProgress.score);\n    }\n  }, []);\n\n  const handleLevelComplete = (levelScore) => {\n    const newTotalScore = totalScore + levelScore;\n    setTotalScore(newTotalScore);\n    \n    if (currentLevel === highestLevel) {\n      const newLevel = highestLevel + 1;\n      setHighestLevel(newLevel);\n      \n      // Save progress\n      saveGameProgress({\n        level: newLevel,\n        score: newTotalScore\n      });\n    }\n\n    setModalMessage(`Level Complete!\\nScore: ${levelScore}\\nTotal Score: ${newTotalScore}`);\n    setShowModal(true);\n  };\n\n  const startLevel = (levelNumber) => {\n    setCurrentLevel(levelNumber);\n    setShowModal(false);\n  };\n\n  const resetGame = () => {\n    clearGameProgress();\n    setCurrentLevel(0);\n    setTotalScore(0);\n    setHighestLevel(1);\n  };\n\n  const renderMenu = () => (\n    <MenuContainer>\n      <h2>Select Level</h2>\n      {levels.map((level, index) => (\n        <Button\n          key={level.id}\n          onClick={(e) => {\n            e.preventDefault();\n            startLevel(index + 1);\n          }}\n          onTouchEnd={(e) => {\n            e.preventDefault();\n            startLevel(index + 1);\n          }}\n          disabled={index + 1 > highestLevel}\n        >\n          Level {level.id}\n        </Button>\n      ))}\n      <Button \n        onClick={(e) => {\n          e.preventDefault();\n          resetGame();\n        }}\n        onTouchEnd={(e) => {\n          e.preventDefault();\n          resetGame();\n        }}\n      >\n        Reset Progress\n      </Button>\n      <h3>Total Score: {totalScore}</h3>\n    </MenuContainer>\n  );\n\n  const renderLevel = () => {\n    const levelData = levels[currentLevel - 1];\n    if (!levelData) {\n      setCurrentLevel(0);\n      return null;\n    }\n\n    return (\n      <>\n        <Button \n          onClick={() => setCurrentLevel(0)}\n          style={{ position: 'absolute', top: '20px', left: '20px' }}\n        >\n          Back to Menu\n        </Button>\n        <Level\n          levelData={levelData}\n          onLevelComplete={handleLevelComplete}\n        />\n      </>\n    );\n  };\n\n  return (\n    <AppContainer>\n      <GameHeader>\n        <Title>Word Search Game</Title>\n      </GameHeader>\n\n      {currentLevel === 0 ? renderMenu() : renderLevel()}\n\n      {showModal && (\n        <ModalOverlay>\n          <Modal>\n            <h2>Congratulations!</h2>\n            <p style={{ whiteSpace: 'pre-line' }}>{modalMessage}</p>\n            <Button \n              onClick={() => {\n                setShowModal(false);\n                setCurrentLevel(currentLevel + 1);\n              }}\n            >\n              Next Level\n            </Button>\n          </Modal>\n        </ModalOverlay>\n      )}\n    </AppContainer>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    -webkit-tap-highlight-color: transparent;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    user-select: none;\n  }\n\n  body {\n    overscroll-behavior: none;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  #root {\n    overflow-y: auto;\n    height: 100%;\n    -webkit-overflow-scrolling: touch;\n  }\n`;\n\n\nconst root = document.getElementById('root');\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n  </React.StrictMode>,\n  root\n);"],"sourceRoot":""}