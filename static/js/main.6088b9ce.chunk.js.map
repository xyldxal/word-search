{"version":3,"sources":["utils/gridHelper.js","components/Grid.js","components/Word.js","components/Timer.js","components/Score.js","utils/wordGenerator.js","utils/storage.js","components/Level.js","utils/gameLogic.js","data/levels.js","App.js","index.js"],"names":["coordsToIndex","x","y","size","indexToCoords","index","Math","floor","getWordFromSelection","selectedIndices","letters","map","join","isValidSelection","length","coords","dx","dy","max","abs","dirX","dirY","i","newDx","newDy","newLength","GridContainer","styled","div","_templateObject","_taggedTemplateLiteral","props","SelectionLine","_templateObject2","Cell","_templateObject3","Grid","_ref","onWordFound","foundWords","selectedCells","setSelectedCells","useState","isDragging","setIsDragging","foundCells","setFoundCells","Set","gridRef","useRef","colors","calculateSelectionStyle","current","gridRect","getBoundingClientRect","totalGaps","cellSize","width","fullCellSize","startCell","endCell","start","end","x1","y1","x2","y2","colorIndex","random","concat","stroke","strokeWidth","useEffect","newFoundCells","startIndex","word","directions","indices","currentWord","currentIndex","newX","newY","push","split","reverse","forEach","add","handleCellMouseUp","React","createElement","ref","onMouseLeave","onTouchStart","e","preventDefault","onTouchMove","touch","touches","cellWidth","cellHeight","height","clientX","left","clientY","top","col","row","newSelection","onTouchEnd","handleTouchEnd","renderHighlights","styles","selectionStyle","_objectSpread","opacity","key","wordIndex","startX","startY","gap","padding","style","position","pointerEvents","strokeLinecap","letter","onMouseDown","handleCellMouseDown","onMouseEnter","handleCellMouseEnter","onMouseUp","handleTouchStart","WordItem","found","Word","TimerContainer","time","Timer","initialTime","onTimeUp","setTime","timer","setInterval","prev","clearInterval","toString","padStart","ScoreContainer","Score","score","DIRECTIONS","canPlaceWord","grid","pos","dir","wordLength","currentCell","placeWord","saveGameProgress","data","localStorage","setItem","JSON","stringify","error","console","loadGameProgress","getItem","parse","clearGameProgress","removeItem","LevelContainer","LevelHeader","WordList","_templateObject4","_templateObject5","button","_templateObject6","Level","levelData","onLevelComplete","onTimeout","setFoundWords","setScore","timeRemaining","setTimeRemaining","timeLimit","setGrid","showModal","setShowModal","modalMessage","setModalMessage","timeoutModal","setTimeoutModal","initializeLevel","newGrid","generateWordSearchGrid","words","Array","fill","placedWords","sort","a","b","placed","attempts","maxAttempts","gridSize","isArray","flat","id","includes","reversedWord","foundWord","find","w","toUpperCase","newFoundWords","wordScore","calculateScore","newScore","level","isLevelComplete","levelWords","every","saveHighScore","highScores","levels","difficulty","AppContainer","GameHeader","Title","h1","MenuContainer","Button","ModalOverlay","Modal","_templateObject7","App","currentLevel","setCurrentLevel","totalScore","setTotalScore","highestLevel","setHighestLevel","savedProgress","handleLevelComplete","levelScore","newTotalScore","newLevel","handleTimeout","startLevel","levelNumber","resetGame","onClick","disabled","renderLevel","Fragment","Date","now","whiteSpace","GlobalStyle","createGlobalStyle","root","document","getElementById","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6088b9ce.chunk.js","sourcesContent":["export const coordsToIndex = (x, y, size) => {\n    return y * size + x;\n  };\n  \n  // Convert index to grid coordinates\n  export const indexToCoords = (index, size) => ({\n    x: index % size,\n    y: Math.floor(index / size)\n  });\n  \n  // Get word from selected cells\n  export const getWordFromSelection = (selectedIndices, letters, size) => {\n    return selectedIndices\n      .map(index => letters[index])\n      .join('');\n  };\n  \n  // Check if selection is valid (continuous and in a straight line)\n  export const isValidSelection = (selectedIndices, size) => {\n    if (selectedIndices.length < 2) return false;\n  \n    const coords = selectedIndices.map(index => indexToCoords(index, size));\n    \n    // Check if points are in line (same row, column, or diagonal)\n    const dx = coords[1].x - coords[0].x;\n    const dy = coords[1].y - coords[0].y;\n    \n    // Normalize direction\n    const length = Math.max(Math.abs(dx), Math.abs(dy));\n    const dirX = dx / length;\n    const dirY = dy / length;\n  \n    // Check if all points follow the same direction\n    for (let i = 2; i < coords.length; i++) {\n      const newDx = coords[i].x - coords[i-1].x;\n      const newDy = coords[i].y - coords[i-1].y;\n      const newLength = Math.max(Math.abs(newDx), Math.abs(newDy));\n      \n      if (newDx/newLength !== dirX || newDy/newLength !== dirY) {\n        return false;\n      }\n    }\n  \n    return true;\n  };","import React, { useState, useRef, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { isValidSelection, getWordFromSelection, indexToCoords, coordsToIndex } from '../utils/gridHelper';\n\nconst GridContainer = styled.div`\n  position: relative;\n  display: grid;\n  grid-template-columns: repeat(${props => props.size}, 1fr);\n  gap: 2px;\n  padding: 10px;\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 100%;\n  max-width: 100%; /* Allow full width for smaller grids */\n  margin: 0 auto;\n  touch-action: none; /* Only prevent default touch actions on the grid */\n\n  @media (max-width: 768px) {\n    padding: 5px;\n    gap: 1px;\n    max-width: 95vw;\n  }\n`;\n\nconst SelectionLine = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 1;\n`;\n\nconst Cell = styled.div`\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  aspect-ratio: 1;\n  font-size: 1.2em;\n  font-weight: bold;\n  cursor: pointer;\n  user-select: none;\n  color: #333;\n\n  @media (max-width: 768px) {\n    font-size: 0.9em;\n  }\n`;\n\nconst Grid = ({ size, letters, onWordFound, foundWords = [] }) => {\n  const [selectedCells, setSelectedCells] = useState([]);\n  const [isDragging, setIsDragging] = useState(false);\n  const [foundCells, setFoundCells] = useState(new Set());\n  const gridRef = useRef(null);\n\n  const colors = [\n    '#FF9AA2', // pink\n    '#FFB7B2', // salmon\n    '#FFDAC1', // peach\n    '#E2F0CB', // light green\n    '#B5EAD7', // mint\n    '#C7CEEA', // periwinkle\n    '#9DD6FF', // light blue\n  ];\n\n  const calculateSelectionStyle = () => {\n    if (selectedCells.length < 2 || !gridRef.current) return null;\n\n    const gridRect = gridRef.current.getBoundingClientRect();\n    const gap = 2;\n    const padding = 10;\n    const totalGaps = size - 1;\n    const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n    const cellSize = availableSpace / size;\n    const fullCellSize = cellSize + gap;\n    \n    const startCell = selectedCells[0];\n    const endCell = selectedCells[selectedCells.length - 1];\n    const start = indexToCoords(startCell, size);\n    const end = indexToCoords(endCell, size);\n\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    \n    // Calculate center points for all cases\n    const x1 = padding + (start.x * fullCellSize) + cellSize/2;\n    const y1 = padding + (start.y * fullCellSize) + cellSize/2;\n    const x2 = padding + (end.x * fullCellSize) + cellSize/2;\n    const y2 = padding + (end.y * fullCellSize) + cellSize/2;\n    \n    const colorIndex = Math.floor(Math.random() * colors.length);\n    \n    return {\n      x1: `${x1}px`,\n      y1: `${y1}px`,\n      x2: `${x2}px`,\n      y2: `${y2}px`,\n      stroke: colors[colorIndex],\n      strokeWidth: cellSize,\n    };\n  };\n\n  const renderHighlights = () => {\n    const styles = [];\n    \n    // Add current selection highlight\n    const selectionStyle = calculateSelectionStyle();\n    if (selectionStyle) {\n      styles.push({\n        ...selectionStyle,\n        opacity: 0.3,\n        key: 'selection'\n      });\n    }\n    \n    // Add permanent highlights for found words\n    foundWords.forEach((word, wordIndex) => {\n      for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let currentWord = '';\n          let x1, y1, x2, y2;\n          \n          const { x: startX, y: startY } = indexToCoords(startIndex, size);\n          const gridRect = gridRef.current.getBoundingClientRect();\n          const gap = 2;\n          const padding = 10;\n          const totalGaps = size - 1;\n          const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n          const cellSize = availableSpace / size;\n          const fullCellSize = cellSize + gap;\n          \n          for (let i = 0; i < word.length; i++) {\n            const newX = startX + (dx * i);\n            const newY = startY + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            \n            if (i === 0) {\n              x1 = padding + (newX * fullCellSize) + cellSize/2;\n              y1 = padding + (newY * fullCellSize) + cellSize/2;\n            } else if (i === word.length - 1) {\n              x2 = padding + (newX * fullCellSize) + cellSize/2;\n              y2 = padding + (newY * fullCellSize) + cellSize/2;\n            }\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            styles.push({\n              x1: `${x1}px`,\n              y1: `${y1}px`,\n              x2: `${x2}px`,\n              y2: `${y2}px`,\n              stroke: colors[wordIndex % colors.length],\n              strokeWidth: cellSize,\n              opacity: 0.3,\n              key: `found-${wordIndex}-${startIndex}-${dx}-${dy}`\n            });\n            break; // Found the word, no need to check other directions from this start point\n          }\n        }\n      }\n    });\n\n    return (\n      <svg\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n        }}\n      >\n        {styles.map(style => (\n          <line\n            key={style.key}\n            x1={style.x1}\n            y1={style.y1}\n            x2={style.x2}\n            y2={style.y2}\n            stroke={style.stroke}\n            strokeWidth={style.strokeWidth}\n            strokeLinecap=\"round\"\n            opacity={style.opacity}\n          />\n        ))}\n      </svg>\n    );\n  };\n\n  useEffect(() => {\n    const style = calculateSelectionStyle();\n    if (!style) return;\n  }, [selectedCells]);\n\n  useEffect(() => {\n    const newFoundCells = new Set();\n    \n    for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n      for (const word of foundWords) {\n        // Check all 8 directions from this starting point\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let indices = [];\n          let currentWord = '';\n          let currentIndex = startIndex;\n          \n          for (let i = 0; i < word.length; i++) {\n            const { x, y } = indexToCoords(currentIndex, size);\n            const newX = x + (dx * i);\n            const newY = y + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            indices.push(index);\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            indices.forEach(index => newFoundCells.add(index));\n          }\n        }\n      }\n    }\n    \n    setFoundCells(newFoundCells);\n  }, [foundWords, letters, size]);\n\n  useEffect(() => {\n    // Reset selected cells when grid size changes\n    setSelectedCells([]);\n  }, [size]);\n\n  const handleCellMouseDown = (index) => {\n    setIsDragging(true);\n    setSelectedCells([index]);\n  };\n\n  const handleCellMouseEnter = (index) => {\n    if (isDragging) {\n      const newSelection = [...selectedCells, index];\n      if (isValidSelection(newSelection, size)) {\n        setSelectedCells(newSelection);\n      }\n    }\n  };\n\n  const handleCellMouseUp = () => {\n    setIsDragging(false);\n    if (selectedCells.length >= 2) {\n      const word = getWordFromSelection(selectedCells, letters, size);\n      onWordFound(word);\n    }\n    setSelectedCells([]);\n  };\n\n  const handleTouchStart = (index, e) => {\n    e.preventDefault();\n    setIsDragging(true);\n    setSelectedCells([index]);\n  };\n\n  const handleTouchMove = (e) => {\n    e.preventDefault();\n    if (!isDragging || !gridRef.current) return;\n\n    const touch = e.touches[0];\n    const grid = gridRef.current;\n    const gridRect = grid.getBoundingClientRect();\n    const cellWidth = gridRect.width / size;\n    const cellHeight = gridRect.height / size;\n\n    // Get touch position relative to grid\n    const x = touch.clientX - gridRect.left;\n    const y = touch.clientY - gridRect.top;\n\n    // Convert to grid coordinates\n    const col = Math.floor(x / cellWidth);\n    const row = Math.floor(y / cellHeight);\n\n    if (col >= 0 && col < size && row >= 0 && row < size) {\n      const index = row * size + col;\n      const newSelection = [...selectedCells];\n      \n      // Only add if it's not the last cell selected\n      if (index !== newSelection[newSelection.length - 1]) {\n        newSelection.push(index);\n        if (isValidSelection(newSelection, size)) {\n          setSelectedCells(newSelection);\n        }\n      }\n    }\n  };\n\n  const handleTouchEnd = () => {\n    if (selectedCells.length >= 2) {\n      const word = getWordFromSelection(selectedCells, letters, size);\n      onWordFound(word);\n    }\n    setIsDragging(false);\n    setSelectedCells([]);\n  };\n\n  return (\n    <GridContainer \n      ref={gridRef}\n      size={size}\n      onMouseLeave={() => {\n        setIsDragging(false);\n        setSelectedCells([]);\n      }}\n      onTouchStart={(e) => e.preventDefault()}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n    >\n      <SelectionLine>\n        {renderHighlights()}\n      </SelectionLine>\n      {letters.map((letter, index) => (\n        <Cell\n          key={index}\n          onMouseDown={() => handleCellMouseDown(index)}\n          onMouseEnter={() => handleCellMouseEnter(index)}\n          onMouseUp={handleCellMouseUp}\n          onTouchStart={(e) => handleTouchStart(index, e)}\n        >\n          {letter}\n        </Cell>\n      ))}\n    </GridContainer>\n  );\n};\n\nexport default Grid;","// src/components/Word.js\nimport React from 'react';\nimport styled from 'styled-components';\n\nconst WordItem = styled.div`\n  padding: 8px 15px;\n  background-color: ${props => props.found ? '#4CAF50' : 'white'};\n  color: ${props => props.found ? 'white' : 'black'};\n  border-radius: 20px;\n  font-weight: bold;\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  transition: all 0.3s ease;\n  \n  @media (max-width: 768px) {\n    padding: 6px 12px;\n    font-size: 0.9em;\n  }\n`;\n\nconst Word = ({ word, found }) => {\n  return (\n    <WordItem found={found}>\n      {word}\n    </WordItem>\n  );\n};\n\nexport default Word;","import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { formatTime } from '../utils/gameLogic';\n\nconst TimerContainer = styled.div`\n  font-size: 1.5rem;\n  font-weight: bold;\n  color: ${props => props.time < 10 ? 'red' : 'black'};\n`;\n\nconst Timer = ({ initialTime, onTimeUp }) => {\n  const [time, setTime] = useState(initialTime);\n\n  // Reset timer when initialTime changes or component remounts\n  useEffect(() => {\n    setTime(initialTime);\n  }, [initialTime]);\n\n  useEffect(() => {\n    if (time <= 0) {\n      onTimeUp();\n      return;\n    }\n\n    const timer = setInterval(() => {\n      setTime(prev => prev - 1);\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, [time, onTimeUp]);\n\n  return (\n    <TimerContainer>\n      Time: {Math.floor(time / 60)}:{(time % 60).toString().padStart(2, '0')}\n    </TimerContainer>\n  );\n};\n\n\nexport default Timer;\n","// src/components/Score.js\r\nimport React from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst ScoreContainer = styled.div`\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: #4CAF50;\r\n  padding: 10px 20px;\r\n  background-color: #f5f5f5;\r\n  border-radius: 10px;\r\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n`;\r\n\r\nconst Score = ({ score }) => {\r\n  return (\r\n    <ScoreContainer>\r\n      Score: {score}\r\n    </ScoreContainer>\r\n  );\r\n};\r\n\r\nexport default Score;","const DIRECTIONS = [\r\n    { x: 1, y: 0 },   // right\r\n    { x: 0, y: 1 },   // down\r\n    { x: 1, y: 1 },   // diagonal right-down\r\n    { x: -1, y: 0 },  // left\r\n    { x: 0, y: -1 },  // up\r\n    { x: -1, y: -1 }, // diagonal left-up\r\n    { x: 1, y: -1 },  // diagonal right-up\r\n    { x: -1, y: 1 },  // diagonal left-down\r\n  ];\r\n  \r\n  // Check if a word can be placed at a specific position and direction\r\n  const canPlaceWord = (grid, word, pos, dir, size) => {\r\n    const { x: dx, y: dy } = dir;\r\n    const wordLength = word.length;\r\n  \r\n    for (let i = 0; i < wordLength; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n  \r\n      // Check boundaries\r\n      if (newX < 0 || newX >= size || newY < 0 || newY >= size) {\r\n        return false;\r\n      }\r\n  \r\n      // Check if cell is empty or has the same letter\r\n      const currentCell = grid[newY][newX];\r\n      if (currentCell !== '' && currentCell !== word[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n  \r\n  // Place a word in the grid\r\n  const placeWord = (grid, word, pos, dir) => {\r\n    const { x: dx, y: dy } = dir;\r\n    \r\n    for (let i = 0; i < word.length; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n      grid[newY][newX] = word[i];\r\n    }\r\n  };\r\n  \r\n  // Generate the complete grid with words\r\n  export const generateWordSearchGrid = (size, words) => {\r\n    // Initialize empty grid\r\n    const grid = Array(size).fill().map(() => Array(size).fill(''));\r\n    const placedWords = [];\r\n  \r\n    // Sort words by length (longest first)\r\n    const sortedWords = [...words].sort((a, b) => b.length - a.length);\r\n  \r\n    // Try to place each word\r\n    sortedWords.forEach(word => {\r\n      let placed = false;\r\n      let attempts = 0;\r\n      const maxAttempts = size * size;\r\n  \r\n      while (!placed && attempts < maxAttempts) {\r\n        const pos = {\r\n          x: Math.floor(Math.random() * size),\r\n          y: Math.floor(Math.random() * size)\r\n        };\r\n        const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];\r\n  \r\n        if (canPlaceWord(grid, word, pos, dir, size)) {\r\n          placeWord(grid, word, pos, dir);\r\n          placedWords.push(word);\r\n          placed = true;\r\n        }\r\n        attempts++;\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty cells with random letters\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    for (let y = 0; y < size; y++) {\r\n      for (let x = 0; x < size; x++) {\r\n        if (grid[y][x] === '') {\r\n          grid[y][x] = letters[Math.floor(Math.random() * letters.length)];\r\n        }\r\n      }\r\n    }\r\n  \r\n    return { grid, placedWords };\r\n  };","// src/utils/storage.js\r\n\r\nconst STORAGE_KEY = 'wordSearchGame';\r\n\r\nexport const saveGameProgress = (data) => {\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error saving game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const loadGameProgress = () => {\r\n  try {\r\n    const data = localStorage.getItem(STORAGE_KEY);\r\n    return data ? JSON.parse(data) : null;\r\n  } catch (error) {\r\n    console.error('Error loading game progress:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const clearGameProgress = () => {\r\n  try {\r\n    localStorage.removeItem(STORAGE_KEY);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error clearing game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const saveHighScore = (level, score) => {\r\n  try {\r\n    const highScores = JSON.parse(localStorage.getItem('wordSearchHighScores') || '{}');\r\n    if (!highScores[level] || score > highScores[level]) {\r\n      highScores[level] = score;\r\n      localStorage.setItem('wordSearchHighScores', JSON.stringify(highScores));\r\n      return true;\r\n    }\r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error saving high score:', error);\r\n    return false;\r\n  }\r\n};","// src/components/Level.js\nimport React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Grid from './Grid';\nimport Word from './Word';\nimport Timer from './Timer';\nimport Score from './Score';\nimport { generateWordSearchGrid } from '../utils/wordGenerator';\nimport { calculateScore, isLevelComplete } from '../utils/gameLogic';\nimport { saveGameProgress, saveHighScore } from '../utils/storage';\n\nconst LevelContainer = styled.div`\n  padding: 20px;\n  max-width: 800px;\n  margin: 0 auto;\n\n  @media (max-width: 768px) {\n    padding: 10px;\n  }\n`;\n\nconst LevelHeader = styled.div`\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n\n  @media (max-width: 768px) {\n    margin-bottom: 10px;\n    gap: 5px;\n\n    h2 {\n      font-size: 1.5rem;\n    }\n  }\n`;\n\nconst WordList = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  gap: 10px;\n  margin-bottom: 20px;\n  justify-content: center;\n\n  @media (max-width: 768px) {\n    gap: 5px;\n    margin-bottom: 10px;\n  }\n`;\n\nconst ModalOverlay = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst Modal = styled.div`\n  background-color: #fff;\n  padding: 20px;\n  border-radius: 10px;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n`;\n\nconst Button = styled.button`\n  background-color: #4CAF50;\n  color: #fff;\n  padding: 10px 20px;\n  border: none;\n  border-radius: 5px;\n  cursor: pointer;\n`;\n\nconst Level = ({ levelData, onLevelComplete, onTimeout }) => {\n  const [foundWords, setFoundWords] = useState([]);\n  const [score, setScore] = useState(0);\n  const [timeRemaining, setTimeRemaining] = useState(levelData.timeLimit);\n  const [grid, setGrid] = useState([]);\n  const [showModal, setShowModal] = useState(false);\n  const [modalMessage, setModalMessage] = useState('');\n  const [timeoutModal, setTimeoutModal] = useState(false);\n\n  useEffect(() => {\n    const initializeLevel = () => {\n      setFoundWords([]);\n      setScore(0);\n      const { grid: newGrid } = generateWordSearchGrid(\n        levelData.gridSize, \n        levelData.words\n      );\n      setGrid(Array.isArray(newGrid) ? newGrid.flat() : []);\n    };\n\n    initializeLevel();\n  }, [levelData]); // Only depend on levelData\n\n  const handleWordFound = (word) => {\n    if (!word) return;\n    \n    const reversedWord = word.split('').reverse().join('');\n    const foundWord = levelData.words.find(w => \n      w.toUpperCase() === word.toUpperCase() || \n      w.toUpperCase() === reversedWord.toUpperCase()\n    );\n    \n    if (foundWord && !foundWords.includes(foundWord)) {\n      const newFoundWords = [...foundWords, foundWord];\n      const wordScore = calculateScore(foundWord.length, timeRemaining);\n      const newScore = score + wordScore;\n      \n      setFoundWords(newFoundWords);\n      setScore(newScore);\n\n      saveGameProgress({\n        level: levelData.id,\n        score: newScore,\n        foundWords: newFoundWords\n      });\n\n      if (isLevelComplete(newFoundWords, levelData.words)) {\n        saveHighScore(levelData.id, newScore);\n        onLevelComplete(newScore);\n      }\n    }\n  };\n\n  const handleTimeUp = () => {\n    if (onTimeout) {\n      onTimeout();\n    }\n  };\n\n  if (!grid.length) return null;\n\n  return (\n    <LevelContainer>\n      <LevelHeader>\n        <h2>Level {levelData.id}</h2>\n        <Score score={score} />\n        <Timer \n          key={`timer-${levelData.id}`} // Add a key to Timer\n          initialTime={levelData.timeLimit}\n          onTimeUp={onTimeout}\n        />\n      </LevelHeader>\n\n      <WordList>\n        {levelData.words.map((word, index) => (\n          <Word\n            key={index}\n            word={word}\n            found={foundWords.includes(word)}\n          />\n        ))}\n      </WordList>\n\n      <Grid\n        size={levelData.gridSize}\n        letters={grid}\n        onWordFound={handleWordFound}\n        foundWords={foundWords}\n      />\n    </LevelContainer>\n  );\n};\n\nexport default Level;","export const calculateScore = (wordLength, timeRemaining) => {\r\n    const baseScore = wordLength * 10;\r\n    const timeBonus = Math.floor(timeRemaining / 10);\r\n    return baseScore + timeBonus;\r\n  };\r\n  \r\n  // Check if level is complete\r\n  export const isLevelComplete = (foundWords, levelWords) => {\r\n    return foundWords.length === levelWords.length &&\r\n      levelWords.every(word => foundWords.includes(word));\r\n  };\r\n  \r\n  // Get difficulty multiplier\r\n  export const getDifficultyMultiplier = (difficulty) => {\r\n    switch (difficulty.toLowerCase()) {\r\n      case 'easy':\r\n        return 1;\r\n      case 'medium':\r\n        return 1.5;\r\n      case 'hard':\r\n        return 2;\r\n      default:\r\n        return 1;\r\n    }\r\n  };\r\n  \r\n  // Format time for display\r\n  export const formatTime = (seconds) => {\r\n    const minutes = Math.floor(seconds / 60);\r\n    const remainingSeconds = seconds % 60;\r\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\r\n  };\r\n  \r\n  // Generate level summary\r\n  export const generateLevelSummary = (score, foundWords, totalTime, difficulty) => {\r\n    const difficultyMultiplier = getDifficultyMultiplier(difficulty);\r\n    const finalScore = Math.floor(score * difficultyMultiplier);\r\n    \r\n    return {\r\n      score: finalScore,\r\n      wordsFound: foundWords.length,\r\n      timeSpent: formatTime(totalTime),\r\n      difficulty,\r\n      perfectScore: foundWords.length === totalTime\r\n    };\r\n  };","// src/data/levels.js\r\nexport const levels = [\r\n    {\r\n      id: 1,\r\n      gridSize: 10,\r\n      words: ['SHABU', 'PEKPEK', 'BURAT', 'KIFFY'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    {\r\n      id: 2,\r\n      gridSize: 10,\r\n      words: ['TONI', 'FOWLER', 'JIAFEI', 'POSAY'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    {\r\n      id: 3,\r\n      gridSize: 10,\r\n      words: ['VLAT', 'POKPOK', 'BETLOG', 'MODTA'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n  ];\r\n  \r\n  export const generateGrid = (size, words) => {\r\n    const grid = Array(size * size).fill('');\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    \r\n    // Place words in grid (simplified version)\r\n    words.forEach(word => {\r\n      const position = Math.floor(Math.random() * (size * size - word.length));\r\n      for (let i = 0; i < word.length; i++) {\r\n        grid[position + i] = word[i];\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty spaces with random letters\r\n    return grid.map(cell => cell === '' ? \r\n      letters.charAt(Math.floor(Math.random() * letters.length)) : cell\r\n    );\r\n  };","import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Level from './components/Level';\nimport { levels } from './data/levels';\nimport { loadGameProgress, saveGameProgress, clearGameProgress } from './utils/storage';\n\nconst AppContainer = styled.div`\n  min-height: 100vh;\n  background-color: #f0f2f5;\n  padding: 20px;\n  \n  @media (max-width: 768px) {\n    padding: 10px;\n  }\n`;\n\nconst GameHeader = styled.div`\n  text-align: center;\n  margin-bottom: 30px;\n  \n  @media (max-width: 768px) {\n    margin-bottom: 15px;\n  }\n`;\n\nconst Title = styled.h1`\n  color: #2c3e50;\n  font-size: 2.5rem;\n  margin-bottom: 10px;\n  \n  @media (max-width: 768px) {\n    font-size: 2rem;\n    margin-bottom: 5px;\n  }\n`;\n\nconst MenuContainer = styled.div`\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 20px;\n  background-color: white;\n  border-radius: 10px;\n  box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n  \n  @media (max-width: 768px) {\n    max-width: 95%;\n    padding: 15px;\n  }\n`;\n\nconst Button = styled.button`\n  padding: 10px 20px;\n  margin: 10px;\n  font-size: 1.1rem;\n  border: none;\n  border-radius: 5px;\n  background-color: #4CAF50;\n  color: white;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  touch-action: manipulation;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none; // Add this\n\n  &:hover {\n    background-color: #45a049;\n  }\n\n  &:active {\n    background-color: #3d8b40;\n    transform: scale(0.98);\n  }\n\n  &:disabled {\n    background-color: #cccccc;\n    cursor: not-allowed;\n  }\n  \n  @media (max-width: 768px) {\n    padding: 15px 30px; // Increased padding for better touch target\n    margin: 8px;\n    font-size: 1.2rem; // Slightly larger font for mobile\n  }\n`;\n\nconst ModalOverlay = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n`;\n\nconst Modal = styled.div`\n  position: relative;\n  background-color: white;\n  padding: 30px;\n  border-radius: 10px;\n  box-shadow: 0 0 20px rgba(0,0,0,0.2);\n  text-align: center;\n  z-index: 1001;\n`;\n\nfunction App() {\n  const [currentLevel, setCurrentLevel] = useState(0);\n  const [totalScore, setTotalScore] = useState(0);\n  const [highestLevel, setHighestLevel] = useState(1);\n  const [showModal, setShowModal] = useState(false);\n  const [modalMessage, setModalMessage] = useState('');\n  const [timeoutModal, setTimeoutModal] = useState(false);\n\n  useEffect(() => {\n    // Load saved progress when app starts\n    const savedProgress = loadGameProgress();\n    if (savedProgress) {\n      setHighestLevel(savedProgress.level);\n      setTotalScore(savedProgress.score);\n    }\n  }, []);\n\n  const handleLevelComplete = (levelScore) => {\n    const newTotalScore = totalScore + levelScore;\n    setTotalScore(newTotalScore);\n    \n    if (currentLevel === highestLevel) {\n      const newLevel = highestLevel + 1;\n      setHighestLevel(newLevel);\n      \n      // Save progress\n      saveGameProgress({\n        level: newLevel,\n        score: newTotalScore\n      });\n    }\n\n    setModalMessage(`Level Complete!\\nScore: ${levelScore}\\nTotal Score: ${newTotalScore}`);\n    setShowModal(true);\n    setTimeoutModal(false);\n  };\n\n  const handleTimeout = () => {\n    setTimeoutModal(true);\n    setModalMessage(\"You ran out of time!\");\n    setShowModal(true);\n  };\n\n  const startLevel = (levelNumber) => {\n    setTimeoutModal(false);\n    setCurrentLevel(levelNumber);\n    setShowModal(false);\n    setModalMessage('');\n  };\n\n  const resetGame = () => {\n    clearGameProgress();\n    setCurrentLevel(0);\n    setTotalScore(0);\n    setHighestLevel(1);\n  };\n\n  const renderMenu = () => (\n    <MenuContainer>\n      <h2>Select Level</h2>\n      {levels.map((level, index) => (\n        <Button\n          key={level.id}\n          onClick={(e) => {\n            e.preventDefault();\n            startLevel(index + 1);\n          }}\n          onTouchEnd={(e) => {\n            e.preventDefault();\n            startLevel(index + 1);\n          }}\n          disabled={index + 1 > highestLevel}\n        >\n          {level.id}\n        </Button>\n      ))}\n      <Button \n        onClick={(e) => {\n          e.preventDefault();\n          resetGame();\n        }}\n        onTouchEnd={(e) => {\n          e.preventDefault();\n          resetGame();\n        }}\n      >\n        Reset Progress\n      </Button>\n      <h3>Total Score: {totalScore}</h3>\n    </MenuContainer>\n  );\n\n  const renderLevel = () => {\n    const levelData = levels[currentLevel - 1];\n    if (!levelData) {\n      setCurrentLevel(0);\n      return null;\n    }\n  \n    return (\n      <>\n        <Button \n          onClick={() => setCurrentLevel(0)}\n          style={{ position: 'absolute', top: '20px', left: '20px' }}\n        >\n          Back to Menu\n        </Button>\n        <Level\n          key={`level-${currentLevel}-${Date.now()}`} // Add this key\n          levelData={levelData}\n          onLevelComplete={handleLevelComplete}\n          onTimeout={handleTimeout}\n        />\n      </>\n    );\n  };\n  \n\n  return (\n    <AppContainer>\n      <GameHeader>\n        <Title>word search</Title>\n      </GameHeader>\n\n      {currentLevel === 0 ? renderMenu() : renderLevel()}\n\n      {showModal && (\n        <ModalOverlay>\n          <Modal>\n            {timeoutModal ? (\n              <>\n                <h2>Time's Up!</h2>\n                <p>{modalMessage}</p>\n                <Button \n                  onClick={() => {\n                    setShowModal(false);\n                    setTimeoutModal(false); // Reset timeout state\n                    startLevel(currentLevel); // Restart the current level\n                  }}\n                >\n                  Try Again\n                </Button>\n                <Button \n                  onClick={() => {\n                    setShowModal(false);\n                    setTimeoutModal(false);\n                    setCurrentLevel(0); // Go back to menu\n                  }}\n                >\n                  Back to Menu\n                </Button>\n              </>\n            ) : (\n              <>\n                <h2>Congratulations!</h2>\n                <p style={{ whiteSpace: 'pre-line' }}>{modalMessage}</p>\n                <Button \n                  onClick={() => {\n                    setShowModal(false);\n                    setCurrentLevel(currentLevel + 1);\n                  }}\n                >\n                  Next Level\n                </Button>\n              </>\n            )}\n          </Modal>\n        </ModalOverlay>\n      )}\n    </AppContainer>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    -webkit-tap-highlight-color: transparent;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    user-select: none;\n  }\n\n  body {\n    overscroll-behavior: none;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  #root {\n    overflow-y: auto;\n    height: 100%;\n    -webkit-overflow-scrolling: touch;\n  }\n`;\n\n\nconst root = document.getElementById('root');\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n  </React.StrictMode>,\n  root\n);"],"sourceRoot":""}