{"version":3,"sources":["utils/gridHelper.js","components/Grid.js","components/Word.js","utils/gameLogic.js","components/Timer.js","components/Score.js","utils/wordGenerator.js","utils/storage.js","components/Level.js","data/levels.js","App.js","index.js"],"names":["coordsToIndex","x","y","size","indexToCoords","index","Math","floor","getWordFromSelection","selectedIndices","letters","map","join","isValidSelection","length","coords","dx","dy","max","abs","dirX","dirY","i","newDx","newDy","newLength","GridContainer","styled","div","_templateObject","_taggedTemplateLiteral","props","SelectionLine","_templateObject2","Cell","_templateObject3","Grid","_ref","onWordFound","foundWords","selectedCells","setSelectedCells","useState","isDragging","setIsDragging","foundCells","setFoundCells","Set","gridRef","useRef","colors","calculateSelectionStyle","current","gridRect","getBoundingClientRect","totalGaps","cellSize","width","fullCellSize","startCell","endCell","start","end","x1","y1","x2","y2","colorIndex","random","concat","stroke","strokeWidth","useEffect","newFoundCells","startIndex","word","directions","indices","currentWord","currentIndex","newX","newY","push","split","reverse","forEach","add","handleCellMouseUp","React","createElement","ref","onMouseLeave","onTouchStart","e","preventDefault","onTouchMove","touch","touches","cellWidth","cellHeight","height","clientX","left","clientY","top","col","row","newSelection","onTouchEnd","handleTouchEnd","renderHighlights","styles","selectionStyle","_objectSpread","opacity","key","wordIndex","startX","startY","gap","padding","style","position","pointerEvents","strokeLinecap","letter","onMouseDown","handleCellMouseDown","onMouseEnter","handleCellMouseEnter","onMouseUp","handleTouchStart","WordListContainer","WordItem","found","Word","words","includes","formatTime","seconds","minutes","remainingSeconds","toString","padStart","TimerContainer","time","Timer","initialTime","onTimeUp","setTime","timer","setInterval","prev","clearInterval","ScoreContainer","Score","score","DIRECTIONS","canPlaceWord","grid","pos","dir","wordLength","currentCell","placeWord","generateWordSearchGrid","Array","fill","placedWords","sort","a","b","placed","attempts","maxAttempts","saveGameProgress","data","localStorage","setItem","JSON","stringify","error","console","loadGameProgress","getItem","parse","LevelContainer","LevelHeader","WordList","Level","levelData","onLevelComplete","setFoundWords","setScore","timeRemaining","setTimeRemaining","timeLimit","setGrid","newGrid","gridSize","id","flat","reversedWord","foundWord","find","w","newFoundWords","wordScore","calculateScore","newScore","level","isLevelComplete","levelWords","every","saveHighScore","highScores","levels","difficulty","AppContainer","GameHeader","Title","h1","MenuContainer","_templateObject4","Button","button","_templateObject5","ModalOverlay","_templateObject6","Modal","_templateObject7","App","currentLevel","setCurrentLevel","totalScore","setTotalScore","highestLevel","setHighestLevel","showModal","setShowModal","modalMessage","setModalMessage","savedProgress","handleLevelComplete","levelScore","newTotalScore","newLevel","onClick","levelNumber","startLevel","disabled","renderLevel","l","whiteSpace","GlobalStyle","createGlobalStyle","root","document","getElementById","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.23936b26.chunk.js","sourcesContent":["export const coordsToIndex = (x, y, size) => {\n    return y * size + x;\n  };\n  \n  // Convert index to grid coordinates\n  export const indexToCoords = (index, size) => ({\n    x: index % size,\n    y: Math.floor(index / size)\n  });\n  \n  // Get word from selected cells\n  export const getWordFromSelection = (selectedIndices, letters, size) => {\n    return selectedIndices\n      .map(index => letters[index])\n      .join('');\n  };\n  \n  // Check if selection is valid (continuous and in a straight line)\n  export const isValidSelection = (selectedIndices, size) => {\n    if (selectedIndices.length < 2) return false;\n  \n    const coords = selectedIndices.map(index => indexToCoords(index, size));\n    \n    // Check if points are in line (same row, column, or diagonal)\n    const dx = coords[1].x - coords[0].x;\n    const dy = coords[1].y - coords[0].y;\n    \n    // Normalize direction\n    const length = Math.max(Math.abs(dx), Math.abs(dy));\n    const dirX = dx / length;\n    const dirY = dy / length;\n  \n    // Check if all points follow the same direction\n    for (let i = 2; i < coords.length; i++) {\n      const newDx = coords[i].x - coords[i-1].x;\n      const newDy = coords[i].y - coords[i-1].y;\n      const newLength = Math.max(Math.abs(newDx), Math.abs(newDy));\n      \n      if (newDx/newLength !== dirX || newDy/newLength !== dirY) {\n        return false;\n      }\n    }\n  \n    return true;\n  };","import React, { useState, useRef, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { isValidSelection, getWordFromSelection, indexToCoords, coordsToIndex } from '../utils/gridHelper';\n\nconst GridContainer = styled.div`\n  position: relative;\n  display: grid;\n  grid-template-columns: repeat(${props => props.size}, 1fr);\n  gap: 2px;\n  padding: 10px;\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 100%;\n  max-width: 700px;\n  margin: 0 auto;\n\n  @media (max-width: 768px) {\n    padding: 5px;\n    gap: 1px;\n    max-width: 95vw;\n  }\n`;\n\nconst SelectionLine = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 1;\n`;\n\nconst Cell = styled.div`\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  aspect-ratio: 1;\n  font-size: 1.2em;\n  font-weight: bold;\n  cursor: pointer;\n  user-select: none;\n  color: #333;\n  touch-action: none; /* Prevent default touch actions */\n\n  @media (max-width: 768px) {\n    font-size: 0.9em;\n  }\n`;\n\nconst Grid = ({ size, letters, onWordFound, foundWords = [] }) => {\n  const [selectedCells, setSelectedCells] = useState([]);\n  const [isDragging, setIsDragging] = useState(false);\n  const [foundCells, setFoundCells] = useState(new Set());\n  const gridRef = useRef(null);\n\n  const colors = [\n    '#FF9AA2', // pink\n    '#FFB7B2', // salmon\n    '#FFDAC1', // peach\n    '#E2F0CB', // light green\n    '#B5EAD7', // mint\n    '#C7CEEA', // periwinkle\n    '#9DD6FF', // light blue\n  ];\n\n  const calculateSelectionStyle = () => {\n    if (selectedCells.length < 2 || !gridRef.current) return null;\n\n    const gridRect = gridRef.current.getBoundingClientRect();\n    const gap = 2;\n    const padding = 10;\n    const totalGaps = size - 1;\n    const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n    const cellSize = availableSpace / size;\n    const fullCellSize = cellSize + gap;\n    \n    const startCell = selectedCells[0];\n    const endCell = selectedCells[selectedCells.length - 1];\n    const start = indexToCoords(startCell, size);\n    const end = indexToCoords(endCell, size);\n\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    \n    // Calculate center points for all cases\n    const x1 = padding + (start.x * fullCellSize) + cellSize/2;\n    const y1 = padding + (start.y * fullCellSize) + cellSize/2;\n    const x2 = padding + (end.x * fullCellSize) + cellSize/2;\n    const y2 = padding + (end.y * fullCellSize) + cellSize/2;\n    \n    const colorIndex = Math.floor(Math.random() * colors.length);\n    \n    return {\n      x1: `${x1}px`,\n      y1: `${y1}px`,\n      x2: `${x2}px`,\n      y2: `${y2}px`,\n      stroke: colors[colorIndex],\n      strokeWidth: cellSize,\n    };\n  };\n\n  const renderHighlights = () => {\n    const styles = [];\n    \n    // Add current selection highlight\n    const selectionStyle = calculateSelectionStyle();\n    if (selectionStyle) {\n      styles.push({\n        ...selectionStyle,\n        opacity: 0.3,\n        key: 'selection'\n      });\n    }\n    \n    // Add permanent highlights for found words\n    foundWords.forEach((word, wordIndex) => {\n      for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let currentWord = '';\n          let x1, y1, x2, y2;\n          \n          const { x: startX, y: startY } = indexToCoords(startIndex, size);\n          const gridRect = gridRef.current.getBoundingClientRect();\n          const gap = 2;\n          const padding = 10;\n          const totalGaps = size - 1;\n          const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n          const cellSize = availableSpace / size;\n          const fullCellSize = cellSize + gap;\n          \n          for (let i = 0; i < word.length; i++) {\n            const newX = startX + (dx * i);\n            const newY = startY + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            \n            if (i === 0) {\n              x1 = padding + (newX * fullCellSize) + cellSize/2;\n              y1 = padding + (newY * fullCellSize) + cellSize/2;\n            } else if (i === word.length - 1) {\n              x2 = padding + (newX * fullCellSize) + cellSize/2;\n              y2 = padding + (newY * fullCellSize) + cellSize/2;\n            }\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            styles.push({\n              x1: `${x1}px`,\n              y1: `${y1}px`,\n              x2: `${x2}px`,\n              y2: `${y2}px`,\n              stroke: colors[wordIndex % colors.length],\n              strokeWidth: cellSize,\n              opacity: 0.3,\n              key: `found-${wordIndex}-${startIndex}-${dx}-${dy}`\n            });\n            break; // Found the word, no need to check other directions from this start point\n          }\n        }\n      }\n    });\n\n    return (\n      <svg\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n        }}\n      >\n        {styles.map(style => (\n          <line\n            key={style.key}\n            x1={style.x1}\n            y1={style.y1}\n            x2={style.x2}\n            y2={style.y2}\n            stroke={style.stroke}\n            strokeWidth={style.strokeWidth}\n            strokeLinecap=\"round\"\n            opacity={style.opacity}\n          />\n        ))}\n      </svg>\n    );\n  };\n\n  useEffect(() => {\n    const style = calculateSelectionStyle();\n    if (!style) return;\n  }, [selectedCells]);\n\n  useEffect(() => {\n    const newFoundCells = new Set();\n    \n    for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n      for (const word of foundWords) {\n        // Check all 8 directions from this starting point\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let indices = [];\n          let currentWord = '';\n          let currentIndex = startIndex;\n          \n          for (let i = 0; i < word.length; i++) {\n            const { x, y } = indexToCoords(currentIndex, size);\n            const newX = x + (dx * i);\n            const newY = y + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            indices.push(index);\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            indices.forEach(index => newFoundCells.add(index));\n          }\n        }\n      }\n    }\n    \n    setFoundCells(newFoundCells);\n  }, [foundWords, letters, size]);\n\n  const handleCellMouseDown = (index) => {\n    setIsDragging(true);\n    setSelectedCells([index]);\n  };\n\n  const handleCellMouseEnter = (index) => {\n    if (isDragging) {\n      const newSelection = [...selectedCells, index];\n      if (isValidSelection(newSelection, size)) {\n        setSelectedCells(newSelection);\n      }\n    }\n  };\n\n  const handleCellMouseUp = () => {\n    setIsDragging(false);\n    if (selectedCells.length >= 2) {\n      const word = getWordFromSelection(selectedCells, letters, size);\n      onWordFound(word);\n    }\n    setSelectedCells([]);\n  };\n\n  const handleTouchStart = (index, e) => {\n    e.preventDefault();\n    setIsDragging(true);\n    setSelectedCells([index]);\n  };\n\n  const handleTouchMove = (e) => {\n    e.preventDefault();\n    if (!isDragging || !gridRef.current) return;\n\n    const touch = e.touches[0];\n    const grid = gridRef.current;\n    const gridRect = grid.getBoundingClientRect();\n    const cellWidth = gridRect.width / size;\n    const cellHeight = gridRect.height / size;\n\n    // Get touch position relative to grid\n    const x = touch.clientX - gridRect.left;\n    const y = touch.clientY - gridRect.top;\n\n    // Convert to grid coordinates\n    const col = Math.floor(x / cellWidth);\n    const row = Math.floor(y / cellHeight);\n\n    if (col >= 0 && col < size && row >= 0 && row < size) {\n      const index = row * size + col;\n      const newSelection = [...selectedCells];\n      \n      // Only add if it's not the last cell selected\n      if (index !== newSelection[newSelection.length - 1]) {\n        newSelection.push(index);\n        if (isValidSelection(newSelection, size)) {\n          setSelectedCells(newSelection);\n        }\n      }\n    }\n  };\n\n  const handleTouchEnd = () => {\n    if (selectedCells.length >= 2) {\n      const word = getWordFromSelection(selectedCells, letters, size);\n      onWordFound(word);\n    }\n    setIsDragging(false);\n    setSelectedCells([]);\n  };\n\n  return (\n    <GridContainer \n      ref={gridRef}\n      size={size}\n      onMouseLeave={() => {\n        setIsDragging(false);\n        setSelectedCells([]);\n      }}\n      onTouchStart={(e) => e.preventDefault()}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n    >\n      <SelectionLine>\n        {renderHighlights()}\n      </SelectionLine>\n      {letters.map((letter, index) => (\n        <Cell\n          key={index}\n          onMouseDown={() => handleCellMouseDown(index)}\n          onMouseEnter={() => handleCellMouseEnter(index)}\n          onMouseUp={handleCellMouseUp}\n          onTouchStart={(e) => handleTouchStart(index, e)}\n        >\n          {letter}\n        </Cell>\n      ))}\n    </GridContainer>\n  );\n};\n\nexport default Grid;","// src/components/Word.js\r\nimport React from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst WordListContainer = styled.div`\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  gap: 10px;\r\n  max-width: 600px;\r\n  margin: 20px auto;\r\n  padding: 15px;\r\n  background-color: #f5f5f5;\r\n  border-radius: 10px;\r\n`;\r\n\r\nconst WordItem = styled.div`\r\n  padding: 8px 15px;\r\n  background-color: ${props => props.found ? '#4CAF50' : 'white'};\r\n  color: ${props => props.found ? 'white' : 'black'};\r\n  border-radius: 20px;\r\n  font-weight: bold;\r\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n  transition: all 0.3s ease;\r\n`;\r\n\r\nconst Word = ({ words, foundWords }) => {\r\n  return (\r\n    <WordListContainer>\r\n      {words.map((word, index) => (\r\n        <WordItem \r\n          key={index}\r\n          found={foundWords.includes(word)}\r\n        >\r\n          {word}\r\n        </WordItem>\r\n      ))}\r\n    </WordListContainer>\r\n  );\r\n};\r\n\r\nexport default Word;","export const calculateScore = (wordLength, timeRemaining) => {\r\n    const baseScore = wordLength * 10;\r\n    const timeBonus = Math.floor(timeRemaining / 10);\r\n    return baseScore + timeBonus;\r\n  };\r\n  \r\n  // Check if level is complete\r\n  export const isLevelComplete = (foundWords, levelWords) => {\r\n    return foundWords.length === levelWords.length &&\r\n      levelWords.every(word => foundWords.includes(word));\r\n  };\r\n  \r\n  // Get difficulty multiplier\r\n  export const getDifficultyMultiplier = (difficulty) => {\r\n    switch (difficulty.toLowerCase()) {\r\n      case 'easy':\r\n        return 1;\r\n      case 'medium':\r\n        return 1.5;\r\n      case 'hard':\r\n        return 2;\r\n      default:\r\n        return 1;\r\n    }\r\n  };\r\n  \r\n  // Format time for display\r\n  export const formatTime = (seconds) => {\r\n    const minutes = Math.floor(seconds / 60);\r\n    const remainingSeconds = seconds % 60;\r\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\r\n  };\r\n  \r\n  // Generate level summary\r\n  export const generateLevelSummary = (score, foundWords, totalTime, difficulty) => {\r\n    const difficultyMultiplier = getDifficultyMultiplier(difficulty);\r\n    const finalScore = Math.floor(score * difficultyMultiplier);\r\n    \r\n    return {\r\n      score: finalScore,\r\n      wordsFound: foundWords.length,\r\n      timeSpent: formatTime(totalTime),\r\n      difficulty,\r\n      perfectScore: foundWords.length === totalTime\r\n    };\r\n  };","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\nimport { formatTime } from '../utils/gameLogic';\r\n\r\nconst TimerContainer = styled.div`\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: ${props => props.time < 10 ? 'red' : 'black'};\r\n`;\r\n\r\nconst Timer = ({ initialTime, onTimeUp }) => {\r\n  const [time, setTime] = useState(initialTime);\r\n\r\n  useEffect(() => {\r\n    if (time === 0) {\r\n      onTimeUp();\r\n      return;\r\n    }\r\n\r\n    const timer = setInterval(() => {\r\n      setTime(prev => prev - 1);\r\n    }, 1000);\r\n\r\n    return () => clearInterval(timer);\r\n  }, [time, onTimeUp]);\r\n\r\n  return (\r\n    <TimerContainer time={time}>\r\n      {formatTime(time)}\r\n    </TimerContainer>\r\n  );\r\n};\r\n\r\nexport default Timer;\r\n","// src/components/Score.js\r\nimport React from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst ScoreContainer = styled.div`\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: #4CAF50;\r\n  padding: 10px 20px;\r\n  background-color: #f5f5f5;\r\n  border-radius: 10px;\r\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n`;\r\n\r\nconst Score = ({ score }) => {\r\n  return (\r\n    <ScoreContainer>\r\n      Score: {score}\r\n    </ScoreContainer>\r\n  );\r\n};\r\n\r\nexport default Score;","const DIRECTIONS = [\r\n    { x: 1, y: 0 },   // right\r\n    { x: 0, y: 1 },   // down\r\n    { x: 1, y: 1 },   // diagonal right-down\r\n    { x: -1, y: 0 },  // left\r\n    { x: 0, y: -1 },  // up\r\n    { x: -1, y: -1 }, // diagonal left-up\r\n    { x: 1, y: -1 },  // diagonal right-up\r\n    { x: -1, y: 1 },  // diagonal left-down\r\n  ];\r\n  \r\n  // Check if a word can be placed at a specific position and direction\r\n  const canPlaceWord = (grid, word, pos, dir, size) => {\r\n    const { x: dx, y: dy } = dir;\r\n    const wordLength = word.length;\r\n  \r\n    for (let i = 0; i < wordLength; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n  \r\n      // Check boundaries\r\n      if (newX < 0 || newX >= size || newY < 0 || newY >= size) {\r\n        return false;\r\n      }\r\n  \r\n      // Check if cell is empty or has the same letter\r\n      const currentCell = grid[newY][newX];\r\n      if (currentCell !== '' && currentCell !== word[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n  \r\n  // Place a word in the grid\r\n  const placeWord = (grid, word, pos, dir) => {\r\n    const { x: dx, y: dy } = dir;\r\n    \r\n    for (let i = 0; i < word.length; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n      grid[newY][newX] = word[i];\r\n    }\r\n  };\r\n  \r\n  // Generate the complete grid with words\r\n  export const generateWordSearchGrid = (size, words) => {\r\n    // Initialize empty grid\r\n    const grid = Array(size).fill().map(() => Array(size).fill(''));\r\n    const placedWords = [];\r\n  \r\n    // Sort words by length (longest first)\r\n    const sortedWords = [...words].sort((a, b) => b.length - a.length);\r\n  \r\n    // Try to place each word\r\n    sortedWords.forEach(word => {\r\n      let placed = false;\r\n      let attempts = 0;\r\n      const maxAttempts = size * size;\r\n  \r\n      while (!placed && attempts < maxAttempts) {\r\n        const pos = {\r\n          x: Math.floor(Math.random() * size),\r\n          y: Math.floor(Math.random() * size)\r\n        };\r\n        const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];\r\n  \r\n        if (canPlaceWord(grid, word, pos, dir, size)) {\r\n          placeWord(grid, word, pos, dir);\r\n          placedWords.push(word);\r\n          placed = true;\r\n        }\r\n        attempts++;\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty cells with random letters\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    for (let y = 0; y < size; y++) {\r\n      for (let x = 0; x < size; x++) {\r\n        if (grid[y][x] === '') {\r\n          grid[y][x] = letters[Math.floor(Math.random() * letters.length)];\r\n        }\r\n      }\r\n    }\r\n  \r\n    return { grid, placedWords };\r\n  };","// src/utils/storage.js\r\n\r\nconst STORAGE_KEY = 'wordSearchGame';\r\n\r\nexport const saveGameProgress = (data) => {\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error saving game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const loadGameProgress = () => {\r\n  try {\r\n    const data = localStorage.getItem(STORAGE_KEY);\r\n    return data ? JSON.parse(data) : null;\r\n  } catch (error) {\r\n    console.error('Error loading game progress:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const clearGameProgress = () => {\r\n  try {\r\n    localStorage.removeItem(STORAGE_KEY);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error clearing game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const saveHighScore = (level, score) => {\r\n  try {\r\n    const highScores = JSON.parse(localStorage.getItem('wordSearchHighScores') || '{}');\r\n    if (!highScores[level] || score > highScores[level]) {\r\n      highScores[level] = score;\r\n      localStorage.setItem('wordSearchHighScores', JSON.stringify(highScores));\r\n      return true;\r\n    }\r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error saving high score:', error);\r\n    return false;\r\n  }\r\n};","// src/components/Level.js\nimport React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Grid from './Grid';\nimport Word from './Word';\nimport Timer from './Timer';\nimport Score from './Score';\nimport { generateWordSearchGrid } from '../utils/wordGenerator';\nimport { calculateScore, isLevelComplete } from '../utils/gameLogic';\nimport { saveGameProgress, saveHighScore } from '../utils/storage';\n\nconst LevelContainer = styled.div`\n  padding: 20px;\n  max-width: 800px;\n  margin: 0 auto;\n\n  @media (max-width: 768px) {\n    padding: 10px;\n  }\n`;\n\nconst LevelHeader = styled.div`\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n\n  @media (max-width: 768px) {\n    margin-bottom: 10px;\n    gap: 5px;\n\n    h2 {\n      font-size: 1.5rem;\n    }\n  }\n`;\n\nconst WordList = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  gap: 10px;\n  margin-bottom: 20px;\n  justify-content: center;\n\n  @media (max-width: 768px) {\n    gap: 5px;\n    margin-bottom: 10px;\n  }\n`;\n\nconst Level = ({ levelData, onLevelComplete }) => {\n  const [foundWords, setFoundWords] = useState([]);\n  const [score, setScore] = useState(0);\n  const [timeRemaining, setTimeRemaining] = useState(levelData.timeLimit);\n  const [grid, setGrid] = useState([]);\n\n  useEffect(() => {\n    // Generate grid when level starts\n    const { grid: newGrid } = generateWordSearchGrid(\n      levelData.gridSize, \n      levelData.words\n    );\n    setGrid(newGrid);\n  }, [levelData]);\n\n  const handleWordFound = (word) => {\n    // Check both forward and reverse directions\n    const reversedWord = word.split('').reverse().join('');\n    const foundWord = levelData.words.find(w => w === word || w === reversedWord);\n    \n    if (foundWord && !foundWords.includes(foundWord)) {\n      const newFoundWords = [...foundWords, foundWord];\n      const wordScore = calculateScore(foundWord.length, timeRemaining);\n      const newScore = score + wordScore;\n      \n      setFoundWords(newFoundWords);\n      setScore(newScore);\n\n      // Save progress\n      saveGameProgress({\n        level: levelData.id,\n        score: newScore,\n        foundWords: newFoundWords\n      });\n\n      if (isLevelComplete(newFoundWords, levelData.words)) {\n        saveHighScore(levelData.id, newScore);\n        onLevelComplete(newScore);\n      }\n    }\n  };\n\n  return (\n    <LevelContainer>\n      <LevelHeader>\n        <h2>Level {levelData.id}</h2>\n        <Score score={score} />\n        <Timer \n          initialTime={levelData.timeLimit}\n          onTimeUp={() => onLevelComplete(score)}\n        />\n      </LevelHeader>\n\n      <WordList>\n        <Word \n          words={levelData.words}\n          foundWords={foundWords}\n        />\n      </WordList>\n\n      <Grid\n        size={levelData.gridSize}\n        letters={grid.flat()} // Convert 2D array to 1D\n        onWordFound={handleWordFound}\n        foundWords={foundWords}\n      />\n    </LevelContainer>\n  );\n};\n\nexport default Level;","// src/data/levels.js\r\nexport const levels = [\r\n    {\r\n      id: 1,\r\n      gridSize: 15,\r\n      words: ['SHABU', 'PEKPEK', 'BURAT', 'KIFFY', 'VLAT', 'POKPOK', 'BETLOG'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    {\r\n      id: 2,\r\n      gridSize: 15,\r\n      words: ['TONI', 'FOWLER', 'JIAFEI'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    // Add more levels following the same pattern\r\n  ];\r\n  \r\n  // Helper function to generate the grid for each level\r\n  export const generateGrid = (size, words) => {\r\n    // Create empty grid\r\n    const grid = Array(size * size).fill('');\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    \r\n    // Place words in grid (simplified version)\r\n    words.forEach(word => {\r\n      const position = Math.floor(Math.random() * (size * size - word.length));\r\n      for (let i = 0; i < word.length; i++) {\r\n        grid[position + i] = word[i];\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty spaces with random letters\r\n    return grid.map(cell => cell === '' ? \r\n      letters.charAt(Math.floor(Math.random() * letters.length)) : cell\r\n    );\r\n  };","import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Level from './components/Level';\nimport { levels } from './data/levels';\nimport { loadGameProgress, saveGameProgress, clearGameProgress } from './utils/storage';\nimport { generateWordSearchGrid } from './utils/wordGenerator';\n\nconst AppContainer = styled.div`\n  min-height: 100vh;\n  background-color: #f0f2f5;\n  padding: 20px;\n  \n  @media (max-width: 768px) {\n    padding: 10px;\n  }\n`;\n\nconst GameHeader = styled.div`\n  text-align: center;\n  margin-bottom: 30px;\n  \n  @media (max-width: 768px) {\n    margin-bottom: 15px;\n  }\n`;\n\nconst Title = styled.h1`\n  color: #2c3e50;\n  font-size: 2.5rem;\n  margin-bottom: 10px;\n  \n  @media (max-width: 768px) {\n    font-size: 2rem;\n    margin-bottom: 5px;\n  }\n`;\n\nconst MenuContainer = styled.div`\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 20px;\n  background-color: white;\n  border-radius: 10px;\n  box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n  \n  @media (max-width: 768px) {\n    max-width: 95%;\n    padding: 15px;\n  }\n`;\n\nconst Button = styled.button`\n  padding: 10px 20px;\n  margin: 10px;\n  font-size: 1.1rem;\n  border: none;\n  border-radius: 5px;\n  background-color: #4CAF50;\n  color: white;\n  cursor: pointer;\n  transition: all 0.3s ease;\n\n  &:hover {\n    background-color: #45a049;\n  }\n\n  &:disabled {\n    background-color: #cccccc;\n    cursor: not-allowed;\n  }\n  \n  @media (max-width: 768px) {\n    padding: 8px 16px;\n    font-size: 1rem;\n    margin: 5px;\n  }\n`;\n\nconst ModalOverlay = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n`;\n\nconst Modal = styled.div`\n  position: relative;\n  background-color: white;\n  padding: 30px;\n  border-radius: 10px;\n  box-shadow: 0 0 20px rgba(0,0,0,0.2);\n  text-align: center;\n  z-index: 1001;\n`;\n\nfunction App() {\n  const [currentLevel, setCurrentLevel] = useState(0);\n  const [totalScore, setTotalScore] = useState(0);\n  const [highestLevel, setHighestLevel] = useState(1);\n  const [showModal, setShowModal] = useState(false);\n  const [modalMessage, setModalMessage] = useState('');\n\n  useEffect(() => {\n    // Load saved progress when app starts\n    const savedProgress = loadGameProgress();\n    if (savedProgress) {\n      setHighestLevel(savedProgress.level);\n      setTotalScore(savedProgress.score);\n    }\n  }, []);\n\n  const handleLevelComplete = (levelScore) => {\n    const newTotalScore = totalScore + levelScore;\n    setTotalScore(newTotalScore);\n    \n    if (currentLevel === highestLevel) {\n      const newLevel = highestLevel + 1;\n      setHighestLevel(newLevel);\n      \n      // Save progress\n      saveGameProgress({\n        level: newLevel,\n        score: newTotalScore\n      });\n    }\n\n    setModalMessage(`Level Complete!\\nScore: ${levelScore}\\nTotal Score: ${newTotalScore}`);\n    setShowModal(true);\n  };\n\n\n  const startLevel = (levelNumber) => {\n    setCurrentLevel(levelNumber);\n    setShowModal(false);\n  };\n\n  const resetGame = () => {\n    clearGameProgress();\n    setCurrentLevel(0);\n    setTotalScore(0);\n    setHighestLevel(1);\n  };\n\n\n  const renderMenu = () => (\n    <MenuContainer>\n      <h2>Select Level</h2>\n      {levels.map((level, index) => (\n        <Button\n          key={level.id}\n          onClick={() => startLevel(level.id)}\n          disabled={level.id > highestLevel}\n        >\n          Level {level.id}\n        </Button>\n      ))}\n      <h3>Total Score: {totalScore}</h3>\n    </MenuContainer>\n  );\n\n  const renderLevel = () => {\n    const levelData = levels.find(l => l.id === currentLevel);\n    if (!levelData) return null;\n\n    const { grid } = generateWordSearchGrid(levelData.gridSize, levelData.words);\n    \n    return (\n      <Level\n        levelData={{\n          ...levelData,\n          grid: grid.flat()\n        }}\n        onLevelComplete={handleLevelComplete}\n      />\n    );\n  };\n\n  return (\n    <AppContainer>\n      <GameHeader>\n        <Title>Word Search Game</Title>\n      </GameHeader>\n\n      {currentLevel === 0 ? renderMenu() : renderLevel()}\n\n      {showModal && (\n        <ModalOverlay>\n          <Modal>\n            <h2>Congratulations!</h2>\n            <p style={{ whiteSpace: 'pre-line' }}>{modalMessage}</p>\n            <Button onClick={() => {\n              setShowModal(false);\n              setCurrentLevel(currentLevel + 1);\n            }}>\n              Next Level\n            </Button>\n          </Modal>\n        </ModalOverlay>\n      )}\n    </AppContainer>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n  }\n\n  body {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n      sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n`;\n\nconst root = document.getElementById('root');\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n  </React.StrictMode>,\n  root\n);"],"sourceRoot":""}