{"version":3,"sources":["utils/gridHelper.js","components/Grid.js","components/Word.js","utils/gameLogic.js","components/Timer.js","components/Score.js","utils/wordGenerator.js","utils/storage.js","components/Level.js","data/levels.js","App.js","index.js"],"names":["coordsToIndex","x","y","size","indexToCoords","index","Math","floor","GridContainer","styled","div","_templateObject","_taggedTemplateLiteral","props","SelectionLine","_templateObject2","Cell","_templateObject3","Grid","_ref","letters","onWordFound","foundWords","selectedCells","setSelectedCells","useState","isDragging","setIsDragging","foundCells","setFoundCells","Set","gridRef","useRef","colors","calculateSelectionStyle","length","current","gridRect","getBoundingClientRect","totalGaps","cellSize","width","fullCellSize","startCell","endCell","start","end","x1","y1","x2","y2","colorIndex","random","concat","stroke","strokeWidth","useEffect","newFoundCells","startIndex","word","directions","dx","dy","indices","currentWord","currentIndex","i","newX","newY","push","split","reverse","join","forEach","add","handleCellMouseEnter","newSelection","isValidSelection","selectedIndices","coords","map","max","abs","dirX","dirY","newDx","newDy","newLength","handleCellMouseUp","getWordFromSelection","React","createElement","ref","onMouseLeave","renderHighlights","styles","selectionStyle","_objectSpread","opacity","key","wordIndex","startX","startY","gap","padding","style","position","top","left","height","pointerEvents","strokeLinecap","letter","onMouseDown","handleCellMouseDown","onMouseEnter","onMouseUp","WordListContainer","WordItem","found","Word","words","includes","formatTime","seconds","minutes","remainingSeconds","toString","padStart","TimerContainer","time","Timer","initialTime","onTimeUp","setTime","timer","setInterval","prev","clearInterval","ScoreContainer","Score","score","DIRECTIONS","canPlaceWord","grid","pos","dir","wordLength","currentCell","placeWord","generateWordSearchGrid","Array","fill","placedWords","sort","a","b","placed","attempts","maxAttempts","saveGameProgress","data","localStorage","setItem","JSON","stringify","error","console","loadGameProgress","getItem","parse","LevelContainer","LevelHeader","Level","levelData","onLevelComplete","setFoundWords","setScore","timeRemaining","setTimeRemaining","timeLimit","setGrid","newGrid","gridSize","id","flat","reversedWord","foundWord","find","w","newFoundWords","wordScore","calculateScore","newScore","level","isLevelComplete","levelWords","every","saveHighScore","highScores","levels","difficulty","AppContainer","GameHeader","Title","h1","MenuContainer","_templateObject4","Button","button","_templateObject5","ModalOverlay","_templateObject6","Modal","_templateObject7","App","currentLevel","setCurrentLevel","totalScore","setTotalScore","highestLevel","setHighestLevel","showModal","setShowModal","modalMessage","setModalMessage","savedProgress","handleLevelComplete","levelScore","newTotalScore","newLevel","onClick","levelNumber","startLevel","disabled","renderLevel","l","whiteSpace","GlobalStyle","createGlobalStyle","root","document","getElementById","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2f9afe8f.chunk.js","sourcesContent":["export const coordsToIndex = (x, y, size) => {\n    return y * size + x;\n  };\n  \n  // Convert index to grid coordinates\n  export const indexToCoords = (index, size) => ({\n    x: index % size,\n    y: Math.floor(index / size)\n  });\n  \n  // Get word from selected cells\n  export const getWordFromSelection = (selectedIndices, letters, size) => {\n    return selectedIndices\n      .map(index => letters[index])\n      .join('');\n  };\n  \n  // Check if selection is valid (continuous and in a straight line)\n  export const isValidSelection = (selectedIndices, size) => {\n    if (selectedIndices.length < 2) return false;\n  \n    const coords = selectedIndices.map(index => indexToCoords(index, size));\n    \n    // Check if points are in line (same row, column, or diagonal)\n    const dx = coords[1].x - coords[0].x;\n    const dy = coords[1].y - coords[0].y;\n    \n    // Normalize direction\n    const length = Math.max(Math.abs(dx), Math.abs(dy));\n    const dirX = dx / length;\n    const dirY = dy / length;\n  \n    // Check if all points follow the same direction\n    for (let i = 2; i < coords.length; i++) {\n      const newDx = coords[i].x - coords[i-1].x;\n      const newDy = coords[i].y - coords[i-1].y;\n      const newLength = Math.max(Math.abs(newDx), Math.abs(newDy));\n      \n      if (newDx/newLength !== dirX || newDy/newLength !== dirY) {\n        return false;\n      }\n    }\n  \n    return true;\n  };","import React, { useState, useRef, useEffect } from 'react';\nimport styled from 'styled-components';\nimport { isValidSelection, getWordFromSelection, indexToCoords, coordsToIndex } from '../utils/gridHelper';\n\nconst GridContainer = styled.div`\n  position: relative;\n  display: grid;\n  grid-template-columns: repeat(${props => props.size}, 1fr);\n  gap: 2px;\n  padding: 10px;\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 100%;\n  max-width: 700px;\n  margin: 0 auto;\n`;\n\nconst SelectionLine = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 1;\n`;\n\nconst Cell = styled.div`\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  aspect-ratio: 1;\n  font-size: 1.2em;\n  font-weight: bold;\n  cursor: pointer;\n  user-select: none;\n  color: #333;\n`;\n\nconst Grid = ({ size, letters, onWordFound, foundWords = [] }) => {\n  const [selectedCells, setSelectedCells] = useState([]);\n  const [isDragging, setIsDragging] = useState(false);\n  const [foundCells, setFoundCells] = useState(new Set());\n  const gridRef = useRef(null);\n\n  const colors = [\n    '#FF9AA2', // pink\n    '#FFB7B2', // salmon\n    '#FFDAC1', // peach\n    '#E2F0CB', // light green\n    '#B5EAD7', // mint\n    '#C7CEEA', // periwinkle\n    '#9DD6FF', // light blue\n  ];\n\n  const calculateSelectionStyle = () => {\n    if (selectedCells.length < 2 || !gridRef.current) return null;\n\n    const gridRect = gridRef.current.getBoundingClientRect();\n    const gap = 2;\n    const padding = 10;\n    const totalGaps = size - 1;\n    const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n    const cellSize = availableSpace / size;\n    const fullCellSize = cellSize + gap;\n    \n    const startCell = selectedCells[0];\n    const endCell = selectedCells[selectedCells.length - 1];\n    const start = indexToCoords(startCell, size);\n    const end = indexToCoords(endCell, size);\n\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    \n    // Calculate center points for all cases\n    const x1 = padding + (start.x * fullCellSize) + cellSize/2;\n    const y1 = padding + (start.y * fullCellSize) + cellSize/2;\n    const x2 = padding + (end.x * fullCellSize) + cellSize/2;\n    const y2 = padding + (end.y * fullCellSize) + cellSize/2;\n    \n    const colorIndex = Math.floor(Math.random() * colors.length);\n    \n    return {\n      x1: `${x1}px`,\n      y1: `${y1}px`,\n      x2: `${x2}px`,\n      y2: `${y2}px`,\n      stroke: colors[colorIndex],\n      strokeWidth: cellSize,\n    };\n  };\n\n  const renderHighlights = () => {\n    const styles = [];\n    \n    // Add current selection highlight\n    const selectionStyle = calculateSelectionStyle();\n    if (selectionStyle) {\n      styles.push({\n        ...selectionStyle,\n        opacity: 0.3,\n        key: 'selection'\n      });\n    }\n    \n    // Add permanent highlights for found words\n    foundWords.forEach((word, wordIndex) => {\n      for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let currentWord = '';\n          let x1, y1, x2, y2;\n          \n          const { x: startX, y: startY } = indexToCoords(startIndex, size);\n          const gridRect = gridRef.current.getBoundingClientRect();\n          const gap = 2;\n          const padding = 10;\n          const totalGaps = size - 1;\n          const availableSpace = gridRect.width - (2 * padding) - (totalGaps * gap);\n          const cellSize = availableSpace / size;\n          const fullCellSize = cellSize + gap;\n          \n          for (let i = 0; i < word.length; i++) {\n            const newX = startX + (dx * i);\n            const newY = startY + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            \n            if (i === 0) {\n              x1 = padding + (newX * fullCellSize) + cellSize/2;\n              y1 = padding + (newY * fullCellSize) + cellSize/2;\n            } else if (i === word.length - 1) {\n              x2 = padding + (newX * fullCellSize) + cellSize/2;\n              y2 = padding + (newY * fullCellSize) + cellSize/2;\n            }\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            styles.push({\n              x1: `${x1}px`,\n              y1: `${y1}px`,\n              x2: `${x2}px`,\n              y2: `${y2}px`,\n              stroke: colors[wordIndex % colors.length],\n              strokeWidth: cellSize,\n              opacity: 0.3,\n              key: `found-${wordIndex}-${startIndex}-${dx}-${dy}`\n            });\n            break; // Found the word, no need to check other directions from this start point\n          }\n        }\n      }\n    });\n\n    return (\n      <svg\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          pointerEvents: 'none',\n        }}\n      >\n        {styles.map(style => (\n          <line\n            key={style.key}\n            x1={style.x1}\n            y1={style.y1}\n            x2={style.x2}\n            y2={style.y2}\n            stroke={style.stroke}\n            strokeWidth={style.strokeWidth}\n            strokeLinecap=\"round\"\n            opacity={style.opacity}\n          />\n        ))}\n      </svg>\n    );\n  };\n\n  useEffect(() => {\n    const style = calculateSelectionStyle();\n    if (!style) return;\n  }, [selectedCells]);\n\n  useEffect(() => {\n    const newFoundCells = new Set();\n    \n    for (let startIndex = 0; startIndex < letters.length; startIndex++) {\n      for (const word of foundWords) {\n        // Check all 8 directions from this starting point\n        const directions = [\n          { dx: 1, dy: 0 },    // right\n          { dx: -1, dy: 0 },   // left\n          { dx: 0, dy: 1 },    // down\n          { dx: 0, dy: -1 },   // up\n          { dx: 1, dy: 1 },    // diagonal right-down\n          { dx: -1, dy: -1 },  // diagonal left-up\n          { dx: 1, dy: -1 },   // diagonal right-up\n          { dx: -1, dy: 1 },   // diagonal left-down\n        ];\n\n        for (const { dx, dy } of directions) {\n          let indices = [];\n          let currentWord = '';\n          let currentIndex = startIndex;\n          \n          for (let i = 0; i < word.length; i++) {\n            const { x, y } = indexToCoords(currentIndex, size);\n            const newX = x + (dx * i);\n            const newY = y + (dy * i);\n            \n            // Check boundaries\n            if (newX < 0 || newX >= size || newY < 0 || newY >= size) break;\n            \n            const index = coordsToIndex(newX, newY, size);\n            currentWord += letters[index];\n            indices.push(index);\n          }\n          \n          if (currentWord === word || currentWord === word.split('').reverse().join('')) {\n            indices.forEach(index => newFoundCells.add(index));\n          }\n        }\n      }\n    }\n    \n    setFoundCells(newFoundCells);\n  }, [foundWords, letters, size]);\n\n  const handleCellMouseDown = (index) => {\n    setIsDragging(true);\n    setSelectedCells([index]);\n  };\n\n  const handleCellMouseEnter = (index) => {\n    if (isDragging) {\n      const newSelection = [...selectedCells, index];\n      if (isValidSelection(newSelection, size)) {\n        setSelectedCells(newSelection);\n      }\n    }\n  };\n\n  const handleCellMouseUp = () => {\n    setIsDragging(false);\n    if (selectedCells.length >= 2) {\n      const word = getWordFromSelection(selectedCells, letters, size);\n      onWordFound(word);\n    }\n    setSelectedCells([]);\n  };\n\n  return (\n    <GridContainer \n      ref={gridRef}\n      size={size}\n      onMouseLeave={() => {\n        setIsDragging(false);\n        setSelectedCells([]);\n      }}\n    >\n      <SelectionLine>\n        {renderHighlights()}\n      </SelectionLine>\n      {letters.map((letter, index) => (\n        <Cell\n          key={index}\n          onMouseDown={() => handleCellMouseDown(index)}\n          onMouseEnter={() => handleCellMouseEnter(index)}\n          onMouseUp={handleCellMouseUp}\n        >\n          {letter}\n        </Cell>\n      ))}\n    </GridContainer>\n  );\n};\n\nexport default Grid;","// src/components/Word.js\r\nimport React from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst WordListContainer = styled.div`\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  gap: 10px;\r\n  max-width: 600px;\r\n  margin: 20px auto;\r\n  padding: 15px;\r\n  background-color: #f5f5f5;\r\n  border-radius: 10px;\r\n`;\r\n\r\nconst WordItem = styled.div`\r\n  padding: 8px 15px;\r\n  background-color: ${props => props.found ? '#4CAF50' : 'white'};\r\n  color: ${props => props.found ? 'white' : 'black'};\r\n  border-radius: 20px;\r\n  font-weight: bold;\r\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n  transition: all 0.3s ease;\r\n`;\r\n\r\nconst Word = ({ words, foundWords }) => {\r\n  return (\r\n    <WordListContainer>\r\n      {words.map((word, index) => (\r\n        <WordItem \r\n          key={index}\r\n          found={foundWords.includes(word)}\r\n        >\r\n          {word}\r\n        </WordItem>\r\n      ))}\r\n    </WordListContainer>\r\n  );\r\n};\r\n\r\nexport default Word;","export const calculateScore = (wordLength, timeRemaining) => {\r\n    const baseScore = wordLength * 10;\r\n    const timeBonus = Math.floor(timeRemaining / 10);\r\n    return baseScore + timeBonus;\r\n  };\r\n  \r\n  // Check if level is complete\r\n  export const isLevelComplete = (foundWords, levelWords) => {\r\n    return foundWords.length === levelWords.length &&\r\n      levelWords.every(word => foundWords.includes(word));\r\n  };\r\n  \r\n  // Get difficulty multiplier\r\n  export const getDifficultyMultiplier = (difficulty) => {\r\n    switch (difficulty.toLowerCase()) {\r\n      case 'easy':\r\n        return 1;\r\n      case 'medium':\r\n        return 1.5;\r\n      case 'hard':\r\n        return 2;\r\n      default:\r\n        return 1;\r\n    }\r\n  };\r\n  \r\n  // Format time for display\r\n  export const formatTime = (seconds) => {\r\n    const minutes = Math.floor(seconds / 60);\r\n    const remainingSeconds = seconds % 60;\r\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\r\n  };\r\n  \r\n  // Generate level summary\r\n  export const generateLevelSummary = (score, foundWords, totalTime, difficulty) => {\r\n    const difficultyMultiplier = getDifficultyMultiplier(difficulty);\r\n    const finalScore = Math.floor(score * difficultyMultiplier);\r\n    \r\n    return {\r\n      score: finalScore,\r\n      wordsFound: foundWords.length,\r\n      timeSpent: formatTime(totalTime),\r\n      difficulty,\r\n      perfectScore: foundWords.length === totalTime\r\n    };\r\n  };","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\nimport { formatTime } from '../utils/gameLogic';\r\n\r\nconst TimerContainer = styled.div`\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: ${props => props.time < 10 ? 'red' : 'black'};\r\n`;\r\n\r\nconst Timer = ({ initialTime, onTimeUp }) => {\r\n  const [time, setTime] = useState(initialTime);\r\n\r\n  useEffect(() => {\r\n    if (time === 0) {\r\n      onTimeUp();\r\n      return;\r\n    }\r\n\r\n    const timer = setInterval(() => {\r\n      setTime(prev => prev - 1);\r\n    }, 1000);\r\n\r\n    return () => clearInterval(timer);\r\n  }, [time, onTimeUp]);\r\n\r\n  return (\r\n    <TimerContainer time={time}>\r\n      {formatTime(time)}\r\n    </TimerContainer>\r\n  );\r\n};\r\n\r\nexport default Timer;\r\n","// src/components/Score.js\r\nimport React from 'react';\r\nimport styled from 'styled-components';\r\n\r\nconst ScoreContainer = styled.div`\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: #4CAF50;\r\n  padding: 10px 20px;\r\n  background-color: #f5f5f5;\r\n  border-radius: 10px;\r\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n`;\r\n\r\nconst Score = ({ score }) => {\r\n  return (\r\n    <ScoreContainer>\r\n      Score: {score}\r\n    </ScoreContainer>\r\n  );\r\n};\r\n\r\nexport default Score;","const DIRECTIONS = [\r\n    { x: 1, y: 0 },   // right\r\n    { x: 0, y: 1 },   // down\r\n    { x: 1, y: 1 },   // diagonal right-down\r\n    { x: -1, y: 0 },  // left\r\n    { x: 0, y: -1 },  // up\r\n    { x: -1, y: -1 }, // diagonal left-up\r\n    { x: 1, y: -1 },  // diagonal right-up\r\n    { x: -1, y: 1 },  // diagonal left-down\r\n  ];\r\n  \r\n  // Check if a word can be placed at a specific position and direction\r\n  const canPlaceWord = (grid, word, pos, dir, size) => {\r\n    const { x: dx, y: dy } = dir;\r\n    const wordLength = word.length;\r\n  \r\n    for (let i = 0; i < wordLength; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n  \r\n      // Check boundaries\r\n      if (newX < 0 || newX >= size || newY < 0 || newY >= size) {\r\n        return false;\r\n      }\r\n  \r\n      // Check if cell is empty or has the same letter\r\n      const currentCell = grid[newY][newX];\r\n      if (currentCell !== '' && currentCell !== word[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n  \r\n  // Place a word in the grid\r\n  const placeWord = (grid, word, pos, dir) => {\r\n    const { x: dx, y: dy } = dir;\r\n    \r\n    for (let i = 0; i < word.length; i++) {\r\n      const newX = pos.x + (dx * i);\r\n      const newY = pos.y + (dy * i);\r\n      grid[newY][newX] = word[i];\r\n    }\r\n  };\r\n  \r\n  // Generate the complete grid with words\r\n  export const generateWordSearchGrid = (size, words) => {\r\n    // Initialize empty grid\r\n    const grid = Array(size).fill().map(() => Array(size).fill(''));\r\n    const placedWords = [];\r\n  \r\n    // Sort words by length (longest first)\r\n    const sortedWords = [...words].sort((a, b) => b.length - a.length);\r\n  \r\n    // Try to place each word\r\n    sortedWords.forEach(word => {\r\n      let placed = false;\r\n      let attempts = 0;\r\n      const maxAttempts = size * size;\r\n  \r\n      while (!placed && attempts < maxAttempts) {\r\n        const pos = {\r\n          x: Math.floor(Math.random() * size),\r\n          y: Math.floor(Math.random() * size)\r\n        };\r\n        const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];\r\n  \r\n        if (canPlaceWord(grid, word, pos, dir, size)) {\r\n          placeWord(grid, word, pos, dir);\r\n          placedWords.push(word);\r\n          placed = true;\r\n        }\r\n        attempts++;\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty cells with random letters\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    for (let y = 0; y < size; y++) {\r\n      for (let x = 0; x < size; x++) {\r\n        if (grid[y][x] === '') {\r\n          grid[y][x] = letters[Math.floor(Math.random() * letters.length)];\r\n        }\r\n      }\r\n    }\r\n  \r\n    return { grid, placedWords };\r\n  };","// src/utils/storage.js\r\n\r\nconst STORAGE_KEY = 'wordSearchGame';\r\n\r\nexport const saveGameProgress = (data) => {\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error saving game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const loadGameProgress = () => {\r\n  try {\r\n    const data = localStorage.getItem(STORAGE_KEY);\r\n    return data ? JSON.parse(data) : null;\r\n  } catch (error) {\r\n    console.error('Error loading game progress:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const clearGameProgress = () => {\r\n  try {\r\n    localStorage.removeItem(STORAGE_KEY);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error clearing game progress:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const saveHighScore = (level, score) => {\r\n  try {\r\n    const highScores = JSON.parse(localStorage.getItem('wordSearchHighScores') || '{}');\r\n    if (!highScores[level] || score > highScores[level]) {\r\n      highScores[level] = score;\r\n      localStorage.setItem('wordSearchHighScores', JSON.stringify(highScores));\r\n      return true;\r\n    }\r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error saving high score:', error);\r\n    return false;\r\n  }\r\n};","// src/components/Level.js\nimport React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Grid from './Grid';\nimport Word from './Word';\nimport Timer from './Timer';\nimport Score from './Score';\nimport { generateWordSearchGrid } from '../utils/wordGenerator';\nimport { calculateScore, isLevelComplete } from '../utils/gameLogic';\nimport { saveGameProgress, saveHighScore } from '../utils/storage';\n\nconst LevelContainer = styled.div`\n  padding: 20px;\n  max-width: 800px;\n  margin: 0 auto;\n`;\n\nconst LevelHeader = styled.div`\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n`;\n\nconst Level = ({ levelData, onLevelComplete }) => {\n    const [foundWords, setFoundWords] = useState([]);\n    const [score, setScore] = useState(0);\n    const [timeRemaining, setTimeRemaining] = useState(levelData.timeLimit);\n    const [grid, setGrid] = useState([]);\n  \n    useEffect(() => {\n      // Generate grid when level starts\n      const { grid: newGrid } = generateWordSearchGrid(\n        levelData.gridSize, \n        levelData.words\n      );\n      setGrid(newGrid);\n    }, [levelData]);\n  \n    const handleWordFound = (word) => {\n      // Check both forward and reverse directions\n      const reversedWord = word.split('').reverse().join('');\n      const foundWord = levelData.words.find(w => w === word || w === reversedWord);\n      \n      if (foundWord && !foundWords.includes(foundWord)) {\n        const newFoundWords = [...foundWords, foundWord];\n        const wordScore = calculateScore(foundWord.length, timeRemaining);\n        const newScore = score + wordScore;\n        \n        setFoundWords(newFoundWords);\n        setScore(newScore);\n  \n        // Save progress\n        saveGameProgress({\n          level: levelData.id,\n          score: newScore,\n          foundWords: newFoundWords\n        });\n  \n        if (isLevelComplete(newFoundWords, levelData.words)) {\n          saveHighScore(levelData.id, newScore);\n          onLevelComplete(newScore);\n        }\n      }\n    };\n  \n    return (\n      <LevelContainer>\n        <LevelHeader>\n          <h2>Level {levelData.id}</h2>\n          <Score score={score} />\n          <Timer \n            initialTime={levelData.timeLimit}\n            onTimeUp={() => onLevelComplete(score)}\n          />\n        </LevelHeader>\n  \n        <Word \n          words={levelData.words}\n          foundWords={foundWords}\n        />\n  \n        <Grid\n          size={levelData.gridSize}\n          letters={grid.flat()} // Convert 2D array to 1D\n          onWordFound={handleWordFound}\n          foundWords={foundWords}\n        />\n      </LevelContainer>\n    );\n  };\n  \n  export default Level;","// src/data/levels.js\r\nexport const levels = [\r\n    {\r\n      id: 1,\r\n      gridSize: 15,\r\n      words: ['SHABU', 'PEKPEK', 'BURAT', 'KIFFY', 'VLAT', 'POKPOK', 'BETLOG'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    {\r\n      id: 2,\r\n      gridSize: 15,\r\n      words: ['TONI', 'FOWLER', 'JIAFEI'],\r\n      timeLimit: 120,\r\n      difficulty: 'easy'\r\n    },\r\n    // Add more levels following the same pattern\r\n  ];\r\n  \r\n  // Helper function to generate the grid for each level\r\n  export const generateGrid = (size, words) => {\r\n    // Create empty grid\r\n    const grid = Array(size * size).fill('');\r\n    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    \r\n    // Place words in grid (simplified version)\r\n    words.forEach(word => {\r\n      const position = Math.floor(Math.random() * (size * size - word.length));\r\n      for (let i = 0; i < word.length; i++) {\r\n        grid[position + i] = word[i];\r\n      }\r\n    });\r\n  \r\n    // Fill remaining empty spaces with random letters\r\n    return grid.map(cell => cell === '' ? \r\n      letters.charAt(Math.floor(Math.random() * letters.length)) : cell\r\n    );\r\n  };","import React, { useState, useEffect } from 'react';\nimport styled from 'styled-components';\nimport Level from './components/Level';\nimport { levels } from './data/levels';\nimport { loadGameProgress, saveGameProgress, clearGameProgress } from './utils/storage';\nimport { generateWordSearchGrid } from './utils/wordGenerator';\n\nconst AppContainer = styled.div`\n  min-height: 100vh;\n  background-color: #f0f2f5;\n  padding: 20px;\n`;\n\nconst GameHeader = styled.div`\n  text-align: center;\n  margin-bottom: 30px;\n`;\n\nconst Title = styled.h1`\n  color: #2c3e50;\n  font-size: 2.5rem;\n  margin-bottom: 10px;\n`;\n\nconst MenuContainer = styled.div`\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 20px;\n  background-color: white;\n  border-radius: 10px;\n  box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n`;\n\nconst Button = styled.button`\n  padding: 10px 20px;\n  margin: 10px;\n  font-size: 1.1rem;\n  border: none;\n  border-radius: 5px;\n  background-color: #4CAF50;\n  color: white;\n  cursor: pointer;\n  transition: all 0.3s ease;\n\n  &:hover {\n    background-color: #45a049;\n  }\n\n  &:disabled {\n    background-color: #cccccc;\n    cursor: not-allowed;\n  }\n`;\n\nconst ModalOverlay = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n`;\n\nconst Modal = styled.div`\n  position: relative;\n  background-color: white;\n  padding: 30px;\n  border-radius: 10px;\n  box-shadow: 0 0 20px rgba(0,0,0,0.2);\n  text-align: center;\n  z-index: 1001;\n`;\n\nfunction App() {\n  const [currentLevel, setCurrentLevel] = useState(0);\n  const [totalScore, setTotalScore] = useState(0);\n  const [highestLevel, setHighestLevel] = useState(1);\n  const [showModal, setShowModal] = useState(false);\n  const [modalMessage, setModalMessage] = useState('');\n\n  useEffect(() => {\n    // Load saved progress when app starts\n    const savedProgress = loadGameProgress();\n    if (savedProgress) {\n      setHighestLevel(savedProgress.level);\n      setTotalScore(savedProgress.score);\n    }\n  }, []);\n\n  const handleLevelComplete = (levelScore) => {\n    const newTotalScore = totalScore + levelScore;\n    setTotalScore(newTotalScore);\n    \n    if (currentLevel === highestLevel) {\n      const newLevel = highestLevel + 1;\n      setHighestLevel(newLevel);\n      \n      // Save progress\n      saveGameProgress({\n        level: newLevel,\n        score: newTotalScore\n      });\n    }\n\n    setModalMessage(`Level Complete!\\nScore: ${levelScore}\\nTotal Score: ${newTotalScore}`);\n    setShowModal(true);\n  };\n\n\n  const startLevel = (levelNumber) => {\n    setCurrentLevel(levelNumber);\n    setShowModal(false);\n  };\n\n  const resetGame = () => {\n    clearGameProgress();\n    setCurrentLevel(0);\n    setTotalScore(0);\n    setHighestLevel(1);\n  };\n\n\n  const renderMenu = () => (\n    <MenuContainer>\n      <h2>Select Level</h2>\n      {levels.map((level, index) => (\n        <Button\n          key={level.id}\n          onClick={() => startLevel(level.id)}\n          disabled={level.id > highestLevel}\n        >\n          Level {level.id}\n        </Button>\n      ))}\n      <h3>Total Score: {totalScore}</h3>\n    </MenuContainer>\n  );\n\n  const renderLevel = () => {\n    const levelData = levels.find(l => l.id === currentLevel);\n    if (!levelData) return null;\n\n    const { grid } = generateWordSearchGrid(levelData.gridSize, levelData.words);\n    \n    return (\n      <Level\n        levelData={{\n          ...levelData,\n          grid: grid.flat()\n        }}\n        onLevelComplete={handleLevelComplete}\n      />\n    );\n  };\n\n  return (\n    <AppContainer>\n      <GameHeader>\n        <Title>Word Search Game</Title>\n      </GameHeader>\n\n      {currentLevel === 0 ? renderMenu() : renderLevel()}\n\n      {showModal && (\n        <ModalOverlay>\n          <Modal>\n            <h2>Congratulations!</h2>\n            <p style={{ whiteSpace: 'pre-line' }}>{modalMessage}</p>\n            <Button onClick={() => {\n              setShowModal(false);\n              setCurrentLevel(currentLevel + 1);\n            }}>\n              Next Level\n            </Button>\n          </Modal>\n        </ModalOverlay>\n      )}\n    </AppContainer>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n  }\n\n  body {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n      sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n`;\n\nconst root = document.getElementById('root');\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n  </React.StrictMode>,\n  root\n);"],"sourceRoot":""}